#!/bin/bash
### rsc: An RStudio Server Controller
### 
### Usage:
###  rsc <command> [options]
### 
### Commands:
###  start              Start the RStudio Server
###  stop               Stop the RStudio Server and any R session
###  status             Check whether the RStudio Server is running or not
###  config             Output configuration details
###  reset              Wipe all configuration
###  log                Output rsession log
### 
### Options: 
###  --help             Display the full help page with examples
###  --version          Output version of this software
###  --debug            Output detailed debug information
###  --verbose          Output informative message
###  --force            Force an action
###  --full             Output more information
### 
###  --env-pattern=<re> Regular expression matching environment variables to be
###                     exported. To export all, use "^.+$". To export none,
###                     use "^$". (Default: "^.+$")
###  --port=<int>       A port in [1,65535]. If 'random', a free random port
###                     in [1024,65535] is used. If 'uid', similar to 'random'
###                     but is likely to be unique and deterministic for each
###                     user (Default: 8787)
###  --port-seed=<int>  Random seed used to draw a random port (Default: none)
### ---
###
### Example:
###  rsc --help
###  rsc --version
###
###  rsc start --port=8787
###  rsc start --port=random
###  rsc start --port-seed="$(id -u)" --port=random
###  rsc start --port=uid  ## same as --port-seed="$(id -u)" --port=random
###
###  rsc status
###
###  rsc stop
###
###  rsc config
###  rsc config --full
###  rsc log
###
### Version: 0.3.4-9004
### Copyright: Henrik Bengtsson and Harry Putnam (2021)
### License: MIT

## Import bash utility functions
incl="${BASH_SOURCE%/*}/incl"
utils="${BASH_SOURCE%/*}/utils"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/ports.sh
source "${incl}/ports.sh"


# =========================================================================
# Utility functions
# =========================================================================

# -------------------------------------------------------------------------
# Authentication utilities
# -------------------------------------------------------------------------
function auth_tool {
    local path
    path=${utils}/auth-via-su
    assert_executable "${path}"
    path=$(realpath "${path}")
    echo "${path}"
}

function validate_auth {
    local auth
    auth=$(auth_tool)
    ## Validate correctness of auth-via-su executable (should return false)
    echo "" | AUTH_LOGFILE="" "${auth}" "${USER}" &> /dev/null && error "Validation of '$(basename "${auth}")' failed: ${auth}"
    [[ -n ${AUTH_LOGFILE} ]] && warn_auth_logfile
}

function warn_auth_logfile {
  warn "*************************************************************"
  warn "* Environment variable 'AUTH_LOGFILE' is set.  All usernames"
  warn "* and passwords entered at the RStudio Server login prompt"
  warn "* will be recorded to the file:"
  warn "* ${AUTH_LOGFILE}"
  warn "*************************************************************"
  echo
}


# -------------------------------------------------------------------------
# Configuration utilities
# -------------------------------------------------------------------------
## Need a workdir for sqlite database, otherwise we'd have to be root.
## Also for our rsession.sh
function config_dir {
    local path
    path=${XDG_CONFIG_HOME:-$HOME/.config}
    echo "${path}/rsc"
}

function make_config_dir {
    local workdir
    workdir=$(config_dir)
    mkdir -p "${workdir}"/{run,tmp,var/lib/rstudio-server,/var/run/rstudio-server}
    chmod 700 "${workdir}"/{run,tmp,var/lib/rstudio-server,/var/run/rstudio-server}
}


# -------------------------------------------------------------------------
# Lock-file utilities
# -------------------------------------------------------------------------
## Prevent user from running multiple instances of the RStudio Server
function acquire_lock_file {
    local workdir
    local lockfile
    workdir=$(config_dir)

    lockfile=${workdir}/pid.lock
    if [[ -f "${lockfile}" ]]; then
        error "${USER}, another RStudio Server session of yours is already running on $(rserver_hostname) on this system. See 'rsc status' for details. Please terminate that first, e.g. call 'rsc stop' from that machine. As a last resort, call 'pkill rserver; pkill rsession', remove lock file '${lockfile}', and retry."
    fi
    echo "${PPID}" > "${lockfile}"
}

function remove_lock_file {
    local workdir
    local lockfile
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock
    [[ -f "${lockfile}" ]] && rm "${lockfile}" && mdebug "Lock file removed: ${lockfile}"
}    


function remove_stray_lockfile {
    local workdir
    local lockfile
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock

    mdebug "remove_stray_lockfile() ..."
    
    ## Nothing to do?
    [[ ! -f "${lockfile}" ]] || [[ -n "$(rserver_pid true)" ]] || [[ -n "$(rsession_pid true)" ]] && return 0;
    
    ## Here we know that there's neither a rserver PID nor a rsession PID
    rm "${lockfile}"
    warn "Detected a stray lock file (${lockfile}). This file was removed, because there was no evidence that another instance was running on this system (no PID files for neither 'rserver' nor 'rsession' were found)."

    mdebug "remove_stray_lockfile() ... done"
}


function remove_stray_pid_file {
    local workdir
    local file
    local pid_file
    local pid
    local rserver_hostname
    local what
    what=${1:?}

    mdebug "remove_stray_pid_file(what='${what}'):"
    
    workdir=$(config_dir)
    
    if [[ "${what}" == "rserver" ]]; then
        pid_file="$(rserver_pid_file)"
    elif [[ "${what}" == "rsession" ]]; then
        pid_file="$(rsession_pid_file)"
    else
        error "Unknown PID file type: ${what}"
    fi
    mdebug " - pid_file=${pid_file}"
    
    ## Nothing to do?
    [[ ! -f "${pid_file}" ]] && return 0;

    ## Get PID
    pid=$(read_pid true "${pid_file}")
    mdebug " - pid=${pid}"
    
    ## Empty PID (shouldn't really happen)
    if [[ -z "${pid}" ]]; then
        rm "${pid_file}"
         warn "Detected a stray PID file (${pid_file}). This file was removed, because it was empty."
        return 0
    fi

    ## Nothing to do?
    file="${workdir}/rserver.hostname"
    mdebug " - rserver hostname file=${file}"
    [[ ! -f "${file}" ]] && return 0;

    ## Get rserver hostname
    rserver_hostname=$(cat "${file}")
    mdebug " - rserver hostname=${rserver_hostname}"
    mdebug " - hostname=$(hostname)"

    ## If this process is not running, remove the PID file
    if [[ -z $(check_pid "${pid}" "${rserver_hostname}") ]]; then
        rm "${pid_file}"
        warn "Detected a stray PID file (${pid_file}). This file was removed, because it referred to a ${what} process (PID ${pid} on ${rserver_hostname}) which is no longer running."
        return 0
    fi
}



# -------------------------------------------------------------------------
# Configuration utilities
# -------------------------------------------------------------------------
function make_database_conf {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    {
        echo "provider=sqlite"
        echo "directory=${workdir}/var/lib/rstudio-server"
    } > "${workdir}/database.conf"
}

function make_rserver_conf {
    local workdir
    local port
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    port=${1:?}

    if [[ "${port}" == "random" ]]; then
        port=$(free_random_port "${port_seed}")
    fi
    assert_port_free "${port}"

    {
        ## For legacy accounts with UID in [500,999] on C4
        echo "auth-minimum-user-id=500"

        ## Enable [sic!] multi-user authentication, i.e. don't disable it
        echo "auth-none=0"
        
        echo "auth-pam-helper-path=$(auth_tool)"
        
        ## Require re-sign in if idle for 30 minutes
        ## Specifically, if user makes no input to the RStudio Server, they
        ## will be automatically logged out after this time and be redirected
        ## to the 'Sign in to RStudio' page
        echo "auth-timeout-minutes=30"

        ## Path to RStudio Server configuration file
        echo "database-config-file=${workdir}/database.conf"

        ## Path to the 'rsession' executable
        echo "rsession-path=${workdir}/rsession.sh"
        
        ## Path to 'rsession.conf'
        echo "rsession-config-file=${workdir}/rsession.conf"
        
        echo "secure-cookie-key-file=${workdir}/tmp/my-secure-cookie-key"

        ## Run 'rserver' as a regular non-privileged process
        echo "server-daemonize=0"

        ## Folder where RStudio Server writes run-time state
        echo "server-data-dir=${workdir}/var/run/rstudio-server"

        ## Run 'rserver' as this user
        echo "server-user=${USER:?}"

        ## Default working directory of the 'rserver' process
        echo "server-working-dir=${workdir}"

        ## The web port for the RStudio Server
        echo "www-port=${port:?}"
    } > "${workdir}/rserver.conf"
}


# -------------------------------------------------------------------------
# Misc. utilities
# -------------------------------------------------------------------------
function check_pid {
    local pid
    local hostname
    local pid_exists

    pid=${1:?}
    hostname=${2:-$(hostname)}
    
    ## Output PID if there is such a process, otherwise output nothing
    mdebug "check_pid(pid=${pid}, hostname=${hostname}) ..."

    pid_exists=false
    if [[ -n "${pid}" ]]; then
        ## Check PID on local machine or another machine?
        if [[ "${hostname}" == "$(hostname)" ]]; then
            mdebug "- Checking /proc/${pid} on current machine (${hostname})"
            [[ -d "/proc/${pid}" ]] && pid_exists=true
        else
            mdebug "- Checking /proc/${pid} on ${hostname} over SSH"
            #shellcheck disable=SC2029
            res=$(ssh "${hostname}" "[[ -d '/proc/${pid}' ]] && echo true || echo false") || error "Failed to check process PID ${pid} on ${hostname} over SSH"
            [[ "${res}" == "true" ]] && pid_exists=true
        fi
    fi

    if ${pid_exists}; then
        mdebug "- ${hostname}:/proc/${pid} exists"
        echo "${pid}"
    else
        mdebug "- ${hostname}:/proc/${pid} does not exist"
        echo ""
    fi
    mdebug "check_pid(pid=${pid}, hostname=${hostname}) ... done"
}

function read_pid {
    local keep
    local file
    local pid
    keep="${1:?}"
    file="${2:?}"
    mdebug "read_pid(keep=${keep}, file='${file}') ..."
    pid=
    if [[ -f "${file}" ]]; then
        mdebug "- reading ..."
        pid=$(cat "${file}")
    fi
    mdebug "- pid=${pid}"

    ! $keep && [[ -n ${pid} ]] && pid=$(check_pid "${pid}")
    mdebug "- pid=${pid}"
    
    mdebug "read_pid(keep=${keep}, file='${file}') ... done"
    echo "${pid}"
}    

function dhms_to_minutes {
    local bfr
    local value
    local total
    local multipliers
    local parts
    bfr=${1:?}
    
    parts=()
    until [[ -z "${bfr}" ]]; do
        mdebug "Parsing: ${bfr}"
        echo "${bfr}" | grep -q -F "[[:digit:]]+$" && error "Syntax error: ${bfr}"
        value=$(echo "${bfr}" | sed -E 's/^(.*[[:digit:]]+[:-]|)([[:digit:]]+)$/\2/')
        assert_integer "${value}"
        bfr=$(echo "${bfr}" | sed -E 's/[:-]?([[:digit:]]+)$//')
        parts+=("${value}")
    done
    mdebug "parts=${parts[*]}"

    ## seconds, minutes, hours, days
    multipliers=(1 60 3600 86400)
    total=0
    for (( kk=0; kk < ${#parts[@]}; kk++ )); do
        value=$(( multipliers[kk] * parts[kk] ))
        mdebug "$(printf "%d. %d*%d = %d\n" "${kk}" "${multipliers[${kk}]}" "${parts[${kk}]}" "${value}")"
        total=$(( total + value ))
    done
    mdebug "total=${total} seconds"

    ## Round down to nearest minute
    total=$((total / 60))
    mdebug "total=${total} minutes"
    
    echo "${total}"
}

function on_local_machine {
    ## If who shows a entry with LINE that has :0 or similar, then that
    ## suggests the user is on the current machine, and not logged in
    ## from elsewhere
    who | grep -E "^${USER}" | grep -q -E "[[:space:]]:[[:digit:]]+[[:space:]]"
}

function find_login_host_via_who {
    local bfr
    bfr=$(who | grep -E "^${USER}")
    if [[ -n "${bfr}" ]]; then
        mdebug "1. ${bfr}"
        ## Drop entries with LINE suggesting direct login
        bfr=$(echo "${bfr}" | grep -v -E "[[:space:]]:[[:digit:]]+[[:space:]]")
        mdebug "2. ${bfr}"
        ## Look only at the last entry
        bfr=$(echo "${bfr}" | tail -n -1)
        mdebug "3. ${bfr}"
        ## Extract the hostname
        bfr=$(echo "${bfr}" | sed -E 's/(.*[[:space:]]+[(]|[)][[:space:]]*)//g')
        mdebug "4. ${bfr}"
    fi        
    echo "${bfr}"
}

function find_login_host {
    local host
    local full
    host=${LOGIN_HOSTNAME}
    
    if [[ -z "${host}" ]]; then
        host=$(find_login_host_via_who)
    fi
    
    if [[ -z "${host}" ]]; then
        host="<login-machine>"
    fi

    ## Attempt to look up the DNS entry
    if [[ -n "${host}" ]]; then
        if full=$(host "${host}"); then
            host=$(echo "${full}" | cut -d ' ' -f 1)
        fi
    fi
    echo "${host}"
}

# -------------------------------------------------------------------------
# rsession utilities
# -------------------------------------------------------------------------
## Usage: rs_process_status <pid> <hostname>
function rs_process_status {
    local pid
    local hostname
    pid=${1}
    hostname=${2}
    
    mdebug "rs_process_status(pid=${pid}, hostname=${hostname}):"
    
    ## Check if pid is still active
    [[ -n "${pid}" ]] && pid=$(check_pid "${pid}" "${hostname}")
    
    if [[ -n "${pid}" ]]; then
        echo "running (pid ${pid}) on current machine (${hostname})"
    else
        echo "not running"
    fi
}

function rsession_timeout {
    local timeout
    local bfr
    timeout=${RSTUDIO_RSESSION_TIMEOUT}

    ## Running as a Slurm job?
    if [[ -n "${SLURM_JOB_ID}" ]]; then
        ## Query Slurm for it's requested run-time
        if bfr=$(squeue --jobs="${SLURM_JOB_ID}" --noheader --format="%l" 2> /dev/null); then
            bfr=$(echo "${bfr}" | head -n 1)
            mdebug "Slurm run-time limit: '${bfr}'"
            if [[ -n "${bfr}" ]]; then
                timeout=$(dhms_to_minutes "${bfr}")
            fi
        fi
    fi
    
    if [[ -z "${timeout}" ]]; then
        ## The default is 120 minutes (2 hours)
        timeout=120
    fi
    
    mdebug "rsession timeout: ${timeout} minutes"
    assert_integer "${timeout}"
    export RSTUDIO_RSESSION_TIMEOUT="${timeout}"
    echo "${timeout}"
}


function make_rsession_envs {
    local workdir
    local tf
    local pattern
    local outfile

    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    outfile="${workdir}/rsession.env.parent"
    
    ## Nothing to do?
    if [[ -z ${rsession_inherit_env_pattern} ]] || [[ ${rsession_inherit_env_pattern} == "^$" ]]; then
        rm -f "${outfile}"
        mdebug "Removed: ${workdir}/rsession.env.parent"
        return 0
    fi
    
    tf=$(mktemp) || error "Failed to create a temporary file using 'mktemp' with TMPDIR=${TMPDIR:-<not set>}"
    
    declare -x > "${tf}"
    pattern=${rsession_inherit_env_pattern//^/^declare -x }
    pattern=${pattern//$/=.*$}
    grep -E "${pattern}" "${tf}" > "${tf}.tmp"
    mv "${tf}.tmp" "${tf}" 
    mv "${tf}" "${outfile}"
    mdebug "Created: ${outfile} [$(wc -l "${outfile}" | cut -d ' ' -f 1) variables: $(sed -E 's/(^declare -x |=.*$)//g' "${outfile}" | tr $'\n' ' ' | sed -E 's/ $//' | sed 's/ /, /g')]"
}

function make_rsession_conf {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    rsession_timeout > /dev/null
    {
        ## Number of minutes before a session times out, at which point
        ## the session will either suspend
        echo "session-timeout-minutes=$(rsession_timeout)"
        
        ## The default R_LIBS_USER folder that the R session will use
        echo "r-libs-user=${R_LIBS_USER:?}"
    } > "${workdir}/rsession.conf"
}


function make_rsession_sh {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    cat > "${workdir}/rsession.sh" <<END
#!/usr/bin/env bash

# Set OMP_NUM_THREADS to prevent OpenBLAS (and any other OpenMP-enhanced
# libraries used by R) from spawning more threads than the number of processors
# allocated to the job.
OMP_NUM_THREADS=${OMP_NUM_THREADS:-${SLURM_JOB_CPUS_PER_NODE:-$(nproc 2> /dev/null || echo "1")}}
export OMP_NUM_THREADS

## The PPID can be used to identify child process 'rsession', e.g. ps --ppid <pid>
echo "\${PPID}" > "$workdir/rserver.pid"

RSESSION_LOG_FILE="$workdir/rsession.log"
export RSESSION_LOG_FILE

## Import inherited environment variables?
if [[ -f "${workdir}/rsession.env.parent" ]]; then
    ## (a) Record current env vars
    declare -x > "$workdir/rsession.env.rstudio"
    ## (b) Load inherited env vars
    source "$workdir/rsession.env.parent"
    ## (c) Load recorded env vars (in case they where overwritten)
    source "$workdir/rsession.env.rstudio"
    ## (d) Log env vars to be used
    declare -x > "$workdir/rsession.env"
fi

{
    echo "Time: \$(date --rfc-3339=seconds)"
    echo "hostname: \$(hostname)"
    echo "HOSTNAME: \${HOSTNAME}"
    echo "PPID: \${PPID}"
    echo "PWD: \${PWD}"
    echo "PATH: \${PATH}"
    echo

    echo "R details:"
    R --version 2>&1
    echo

    echo "R_*** environment variables:"
    env | grep -E "^R_"
    echo

    echo "Job-scheduler environment variables:"
    env | grep -E "^(SLURM_)"
    env | grep -E "^(NSLOTS|NHOSTS|SGE_|JOB_|PE_)"
    echo

    echo "Command: exec rsession \${@}"
} > "\${RSESSION_LOG_FILE}"

exec &>> "\${RSESSION_LOG_FILE}"
set -x

exec rsession "\${@}"
END
  
  chmod +x "${workdir}/rsession.sh"
}


function rsession_pid_file {
    local workdir
    workdir=$(config_dir)
    echo "${workdir}/var/run/rstudio-server/rstudio-rsession/${USER}-d.pid"
}

function rsession_pid {
    read_pid "${1:-false}" "$(rsession_pid_file)"
}

function terminate_rsession {
    local pid
    pid=$(rsession_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}" && mdebug "rsession (PID ${pid}) terminated"
}

function rsession_status {
    rs_process_status "$(rsession_pid true)" "$(rserver_hostname)"
}    


# -------------------------------------------------------------------------
# rserver utilities
# -------------------------------------------------------------------------
function rserver_pid_file {
    local workdir
    workdir=$(config_dir)
    ## Note, this file is created by the 'rsession.sh' script, so
    ## it does not exist until user logs in
    echo "${workdir}/rserver.pid"
}

function rserver_pid {
    read_pid "${1:-false}" "$(rserver_pid_file)"
}

function rserver_hostname {
    local workdir
    local file
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    file="${workdir}/rserver.hostname"
    assert_file_exists "${file}"
    res=$(cat "${file}")
    [[ -z "${res}" ]] && error "File is empty: ${file}"
    echo "${res}"
}

function rserver_port {
    local workdir
    local file
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    file="${workdir}/rserver.port"
    assert_file_exists "${file}"
    res=$(cat "${file}")
    [[ -z "${res}" ]] && error "File is empty: ${file}"
    echo "${res}"
}

function rserver_url {
    echo "http://$(rserver_hostname):$(rserver_port)"
}

function terminate_rserver {
    local pid
    pid=$(rserver_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}" && mdebug "rserver (PID ${pid}) terminated"
}

function launch_rserver {
    local workdir
    local rs_pid
    local port
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    hostname > "${workdir}/rserver.hostname"
    grep -E "www-port=" "$(config_dir)/rserver.conf" | sed 's/www-port=//' > "${workdir}/rserver.port"

    port=$(rserver_port)
    assert_port_free "${port}"
    
    pid_file=$(rserver_pid_file)
    mdebug "rserver --config-file=\"${workdir}/rserver.conf\" &"
    if $dryrun; then
        echo "DRYRUN: rserver --config-file=\"${workdir}/rserver.conf\""
        sleep 60 &
    else
        rserver --config-file="${workdir}/rserver.conf" &
    fi
    rs_pid=$!
    echo "${rs_pid}" > "${pid_file}"
    rs_pid=$(rserver_pid)
    mdebug "RStudio Server started (pid ${rs_pid})"
}

function rserver_status {
    local res
    local port
    res=$(rs_process_status "$(rserver_pid true)" "$(rserver_hostname)")
    if [[ "${res}" != "not running" ]]; then
        res="${res} listening on port $(rserver_port)"
    fi
    echo "${res}"
}    


# -------------------------------------------------------------------------
# Signal trap functions
# -------------------------------------------------------------------------
function shutdown {
    mdebug "shutdown() ..."
    terminate_rsession
    terminate_rserver
    remove_lock_file
    {
        remove_stray_lockfile
        remove_stray_pid_file rsession
        remove_stray_pid_file rserver
    } > /dev/null
    mdebug "shutdown() ... done"
}

function on_sigterm {
    mdebug "on_sigterm() ..."
    shutdown
    exit 0
    mdebug "on_sigterm() ... done"
}

function on_sigcont {
    mdebug "on_sigcont() ..."
    shutdown
    exit 0
    mdebug "on_sigcont() ... done"
}

# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=
dryrun=false
force=false
verbose=false
args=()
full=false
port=${RSTUDIO_PORT:-8787}
port_seed=${RSTUDIO_PORT_SEED:-}
[[ -n ${port_seed} ]] && assert_integer "${port_seed}"
field=

## Should 'rsession' inherit exported environment variables from the
## 'rsc' process?  If 'false', then the default behavior of 'rserver'
## is to use a a clean set of environment variables.  That default
## behavior prevents R from seeing, for instance, environment variables
## set by a job scheduler.
rsession_inherit_env_pattern="^.+$"
    

# Parse command-line options
while [[ $# -gt 0 ]]; do
    mdebug "Next CLI argument: $1"
    ## Commands:
    if [[ "$1" == "start" ]]; then
        action="$1"
    elif [[ "$1" == "status" ]]; then
        action="$1"
    elif [[ "$1" == "stop" ]]; then
        action="$1"
    elif [[ "$1" == "reset" ]]; then
        action="$1"
    elif [[ "$1" == "config" ]]; then
        action="$1"
    elif [[ "$1" == "log" ]]; then
        action="$1"

    ## Options (--flags):
    elif [[ "$1" == "--help" ]]; then
        action=help
    elif [[ "$1" == "--version" ]]; then
        action=version
    elif [[ "$1" == "--debug" ]]; then
        debug=true
    elif [[ "$1" == "--dryrun" ]]; then
        dryrun=true
    elif [[ "$1" == "--verbose" ]]; then
        verbose=true
    elif [[ "$1" == "--force" ]]; then
        force=true
    elif [[ "$1" == "--full" ]]; then
        full=true
        
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            merror "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "port" ]]; then
            port=${value}
            if [[ "${port}" == "uid" ]]; then
                port_seed=$(id -u)
                assert_integer "${port_seed}"
                port="random"
            fi
            if [[ "${port}" != "random" ]]; then
                assert_port "${port}"
            fi
        elif [[ "${key}" == "port-seed" ]]; then
            port_seed=${value}
            assert_integer "${port_seed}"
        elif [[ "${key}" == "env" ]]; then
            rsession_inherit_env_pattern="^$"
            if [[ ${value} == "all" ]]; then
                rsession_inherit_env_pattern="^[[:alnum:]]+$"
            elif [[ ${value} == "none" ]]; then
                rsession_inherit_env_pattern="^$"
            fi
        elif [[ "${key}" == "env-pattern" ]]; then
            rsession_inherit_env_pattern="${value}"
        elif [[ "${key}" == "field" ]]; then
            field="${value}"
        else
            merror "Unknown option: $1"
        fi
    ## Additional options to be appended (rarely needed)
    else
        args+=("$1")
    fi
    shift
done


## --help should always be available prior to any validation errors
if [[ -z $action ]]; then
    help
    _exit 0
elif [[ $action == "help" ]]; then
    help full
    _exit 0
elif [[ $action == "version" ]]; then
    version
    _exit 0
fi


# -------------------------------------------------------------------------
# Validate options
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# Initiate
# -------------------------------------------------------------------------
mdebug "action: ${action}"
mdebug "debug: ${debug}"
mdebug "verbose: ${verbose}"
mdebug "dryrun: ${dryrun}"
mdebug "force: ${force}"
mdebug "port: ${port}"
mdebug "port_seed: ${port_seed}"
mdebug "rsession_inherit_env_pattern: ${rsession_inherit_env_pattern}"
mdebug "field: ${field}"
mdebug "args: [n=${#args[@]}] ${args[*]}"


## Remove any stray files
remove_stray_pid_file rserver
remove_stray_pid_file rsession
remove_stray_lockfile

if [[ "${action}" == "config" ]]; then
    files=()
    workdir=$(config_dir)
    echo "config-dir=${workdir}"

    echo "lockfile=${workdir}/pid.lock"

    file=${workdir}/rserver.conf
    echo "config-file=${file}"
    files+=("${file}")

    file=${workdir}/rsession.conf
    echo "config-file=${file}"
    files+=("${file}")

    file=${workdir}/rsession.sh
    echo "rsession-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.sh
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.hostname
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.port
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    echo "rserver-pid-file=$(rserver_pid_file)"
    echo "rsession-pid-file=$(rsession_pid_file)"
    echo "rsession-log-file=${workdir}/rsession.log"

    if $full; then
        echo
        for file in "${files[@]}"; do
            if [[ -f "${file}" ]]; then
                ruler "-"
                echo "${file}"
                ruler "-"
                cat "${file}"
            fi
        done
    fi
elif [[ "${action}" == "log" ]]; then
    workdir=$(config_dir)
    file=${workdir}/rsession.log
    if [[ -f "${file}" ]]; then
        ruler "-"
        echo "${file}"
        ruler "-"
        cat "${file}"
    else
        echo "No rsession log file: ${file}"
    fi
elif [[ "${action}" == "status" ]]; then
    mdebug "rsc status ..."
    rserver_status=$(rserver_status)
    if [[ -z ${field} ]]; then
        printf "%s: %s\n" "rserver" "${rserver_status}"
        printf "%s: %s\n" "rsession" "$(rsession_status)"
        workdir=$(config_dir)
        lockfile=${workdir}/pid.lock
        if [[ -f "${lockfile}" ]]; then
            echo "lock file: exists (${lockfile})"
        else
            echo "lock file: does not exist"
        fi
    else
        [[ "${rserver_status}" == "not running" ]] && error "Not running"
        if [[ "${field}" == "port" ]]; then
            rserver_port
        elif [[ "${field}" == "hostname" ]]; then
            rserver_hostname
        fi
    fi
    mdebug "rsc status ... done"
elif [[ "${action}" == "stop" ]]; then
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock
    ## If running, make sure we're stopping from the correct machine
    if [[ -f "${lockfile}" ]] && [[ "$(hostname)" != "$(rserver_hostname)" ]]; then
        error "Stopping the RStudio Server can only be made from the machine ($(rserver_hostname)) where it was started from"
    fi

    ## Terminate rsession
    pid=$(rsession_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}"

    ## Terminate rserver
    pid=$(rserver_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}"

    ## Remove lock file
    remove_lock_file    
elif [[ "${action}" == "reset" ]]; then
    $force || acquire_lock_file
    workdir=$(config_dir)
    [[ -d "${workdir}" ]] && rm -rf "${workdir}"
elif [[ "${action}" == "start" ]]; then    
    ## Assert executables are available
    assert_executable R
    assert_executable rserver
    assert_executable rsession
    if [[ "${port}" != "random" ]]; then
        assert_port_free "${port}"
    fi
    
    validate_auth
  
    make_config_dir
    acquire_lock_file
    
    make_database_conf
    make_rserver_conf "${port}"
    make_rsession_envs
    make_rsession_sh
    make_rsession_conf

    mdebug "PID for rsc (this process): $$"

    ## For troubleshooting/debugging Slurm termination /HB 2022-01-27
##    for kk in {0..64}; do
##        trap "echo '$0: Caught signal ${kk}'" "${kk}"
##    done
    
    ## Make sure to stop the RStudio Server and any R sessions on exit
    mdebug "Registering 'trap shutdown EXIT', which perform cleanups"
    trap shutdown EXIT

    mdebug "Registering 'trap on_sigterm SIGTERM', which triggers the EXIT trap"
    trap on_sigterm SIGTERM

    mdebug "Registering 'trap on_sigterm SIGCONT', which triggers the EXIT trap"
    trap on_sigcont SIGCONT

    launch_rserver
    
    if on_local_machine; then
        msg="${USER}, your personal RStudio Server is available on <http://127.0.0.1:$(rserver_port)> from this machine ($(rserver_hostname))."
    else
        LOCALPORT=${LOCALPORT:-8787}
        msg="${USER}, your personal RStudio Server is available on <http://$(rserver_hostname):$(rserver_port)>. If you are running from a remote machine without direct access to $(rserver_hostname), you can use SSH port forwarding to access the RStudio Server at <http://127.0.0.1:${LOCALPORT}> by running 'ssh -L ${LOCALPORT}:$(rserver_hostname):$(rserver_port) ${USER}@$(find_login_host)' in a second terminal."
    fi
    msg="${msg} Any R session started times out after being idle for $(rsession_timeout) minutes."

    
    rs_pid="$(rserver_pid)"
    [[ -z "${rs_pid}" ]] && error "RStudio Server failed to start for unknown reasons. One reason for this might that the port (${port}) is already occupied."

    echo "${msg}"
    
    mdebug "Waiting for 'rserver' (pid ${rs_pid}) to finish ..."
    wait "${rs_pid}"
    res=$?
    mdebug "'rserver' exit code: ${res}"
    mdebug "Waiting for 'rserver' (pid ${rs_pid}) to finish ... done"
    mdebug "$0 is exiting..."
fi
