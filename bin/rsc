#!/bin/bash
### rsc: An RStudio Server Controller
### 
### Usage:
###  rsc <command> [options]
### 
### Commands:
###  start        Start the RStudio Server
###  stop         Stop the RStudio Server and any R session
###  status       Check whether the RStudio Server is running or not
###  config       Output configuration details
###  reset        Wipe all configuration
###  log          Output rsession log
###
### Options:
###  --help       Display the full help page with examples
###  --version    Output version of this software
###  --debug      Output detailed debug information
###  --verbose    Output informative message
###  --force      Force an action
###  --full       Output more information
###
###  --port=<int> The port RStudio Server will use (Default: 8787)
### ---
###
### Example:
###  rsc --help
###  rsc --version
###
###  rsc start
###  rsc start --port=8787
###  rsc start --port=random
###
###  rsc status
###
###  rsc stop
###
###  rsc config
###  rsc config --full
###  rsc log
###
### Version: 0.1.2-9001
### Copyright: Henrik Bengtsson and Harry Putnam (2021)
### License: MIT

## Import bash utility functions
incl="${BASH_SOURCE%/*}/incl"
utils="${BASH_SOURCE%/*}/utils"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"


# -------------------------------------------------------------------------
# Utility functions
# -------------------------------------------------------------------------
function ruler {
    ## 70-symbols wide
    echo "----------------------------------------------------------------------"
}

function free_port {
    # get unused socket per https://unix.stackexchange.com/a/132524
    # tiny race condition between the Python and launching the rserver
    python -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()'
}    
   
function warn_auth_logfile {
  warn "*************************************************************"
  warn "* Environment variable 'AUTH_LOGFILE' is set.  All usernames"
  warn "* and passwords entered at the RStudio Server login prompt"
  warn "* will be recorded to the file:"
  warn "* ${AUTH_LOGFILE}"
  warn "*************************************************************"
  echo
}

function auth_tool {
    local path
    path=${utils}/auth-via-su
    assert_executable "${path}"
    path=$(realpath "${path}")
    echo "${path}"
}

function validate_auth {
    local auth
    auth=$(auth_tool)
    ## Validate correctness of auth-via-su executable (should return false)
    echo "" | AUTH_LOGFILE="" "${auth}" "${USER}" > /dev/null && error "Validation of '$(basename "${auth}")' failed: ${auth}"
    [[ -n ${AUTH_LOGFILE} ]] && warn_auth_logfile
}


function validate_port {
    [[ -z $1 ]] && error "Port must not be empty"
    if [[ $1 -lt 0 ]] || [[ $1 -gt 65535 ]]; then
        error "Port out of range [0,65535]: $1"
    fi
}


## Assert executable exist
function assert_executable {
  command -v "$1" &> /dev/null || error "No such executable: $1"
}


## Need a workdir for sqlite database, otherwise we'd have to be root.
## Also for our rsession.sh
function config_dir {
  echo "$HOME/.config/rsc"
}

function make_config_dir {
    local workdir
    workdir=$(config_dir)
    mkdir -p "${workdir}"/{run,tmp,var/lib/rstudio-server,/var/run/rstudio-server}
    chmod 700 "${workdir}"/{run,tmp,var/lib/rstudio-server,/var/run/rstudio-server}
}

## Prevent user from running multiple instances of the RStudio Server
function acquired_lock_file {
    local workdir
    local lockfile
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock
    if [[ -f "${lockfile}" ]]; then
        error "Another RStudio Server session of yours is already active on the system.  Please terminate that first, e.g. 'rsc stop'.  As a last resort, call 'pkill rserver; pkill rsession', remove lock file '${lockfile}', and retry."
    fi
    echo "${PPID}" > "${lockfile}"
}

function remove_lock_file {
    local workdir
    local lockfile
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock
    [[ -f "${lockfile}" ]] && rm "${lockfile}"
}    

function make_database_conf {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    {
        echo "provider=sqlite"
        echo "directory=${workdir}/var/lib/rstudio-server"
    } > "${workdir}/database.conf"
}

function make_rserver_conf {
    local workdir
    local port
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    port=${1:?}

    if [[ "${port}" == "random" ]]; then
        port=$(free_port)
    fi
    validate_port "${port}"
    
    {
        ## For legacy accounts with UID in [500,999] on C4
        echo "auth-minimum-user-id=500"

        ## Enable [sic!] multi-user authentication, i.e. don't disable it
        echo "auth-none=0"
        
        echo "auth-pam-helper-path=$(auth_tool)"
        
        ## Require re-sign in if idle for 30 minutes
        ## Specifically, if user makes no input to the RStudio Server, they
        ## will be automatically logged out after this time and be redirected
        ## to the 'Sign in to RStudio' page
        echo "auth-timeout-minutes=30"

        ## Path to RStudio Server configuration file
        echo "database-config-file=${workdir}/database.conf"

        ## Path to the 'rsession' executable
        echo "rsession-path=${workdir}/rsession.sh"
        
        ## Path to 'rsession.conf'
        echo "rsession-config-file=${workdir}/rsession.conf"
        
        echo "secure-cookie-key-file=${workdir}/tmp/my-secure-cookie-key"

        ## Run 'rserver' as a regular non-privileged process
        echo "server-daemonize=0"

        ## Folder where RStudio Server writes run-time state
        echo "server-data-dir=${workdir}/var/run/rstudio-server"

        ## Run 'rserver' as this user
        echo "server-user=${USER:?}"

        ## Default working directory of the 'rserver' process
        echo "server-working-dir=${workdir}"

        ## The web port for the RStudio Server
        echo "www-port=${port:?}"
    } > "${workdir}/rserver.conf"
}


function make_rsession_conf {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    {
        ## Number of minutes before a session times out, at which point
        ## the session will either suspend
        echo "session-timeout-minutes=120"
        
        ## The default R_LIBS_USER folder that the R session will use
        echo "r-libs-user=${R_LIBS_USER:?}"
    } > "${workdir}/rsession.conf"
}


function make_rsession_sh {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    cat > "${workdir}/rsession.sh" <<END
#!/bin/sh

# Set OMP_NUM_THREADS to prevent OpenBLAS (and any other OpenMP-enhanced
# libraries used by R) from spawning more threads than the number of processors
# allocated to the job.
OMP_NUM_THREADS=${OMP_NUM_THREADS:-${SLURM_JOB_CPUS_PER_NODE:-$(nproc 2> /dev/null || echo "1")}}
export OMP_NUM_THREADS

## The PPID can be used to identify child process 'rsession', e.g. ps --ppid <pid>
echo "\${PPID}" > "$workdir/rserver.pid"

RSESSION_LOG_FILE="$workdir/rsession.log"
export RSESSION_LOG_FILE

{
    echo "Launching rsession:"
    echo "Time: \$(date)"
    echo "HOSTNAME: \${HOSTNAME}"
    echo "PPID: \${PPID}"
    echo "PWD: \${PWD}"
    echo "PATH: \${PATH}"
    echo

    echo "R details:"
    R --version 2>&1
    echo

    echo "R_*** environment variables:"
    env | grep -E "^R_"
    echo

    echo "Job-scheduler environment variables:"
    env | grep -E "^(SLURM_)"
    env | grep -E "^(NSLOTS|NHOSTS|SGE_|JOB_|PE_)"
    echo

    echo "Command: exec rsession \${@}"
} > "\${RSESSION_LOG_FILE}"

exec &>> "\${RSESSION_LOG_FILE}"
set -x

exec rsession "\${@}"
END
  
  chmod +x "${workdir}/rsession.sh"
}


function check_pid {
    ## Output PID if there is such a process, otherwise output nothing
    if [[ -n "${1}" ]] && [[ -d "/proc/${1}" ]]; then
        echo "${1}"
    else
        echo ""
    fi
}

function read_pid {
    local pid
    pid=
    if [[ -f "$1" ]]; then
        pid=$(cat "$1")
    fi
    check_pid "${pid}"
}    


function rserver_pid_file {
    local workdir
    workdir=$(config_dir)
    ## Note, this file is created by the 'rsession.sh' script, so
    ## it does not exist until user logs in
    echo "${workdir}/rserver.pid"
}

function rserver_pid {
    read_pid "$(rserver_pid_file)"
}

function rsession_pid_file {
    local workdir
    workdir=$(config_dir)
    echo "${workdir}/var/run/rstudio-server/rstudio-rsession/${USER}-d.pid"
}

function rsession_pid {
    read_pid "$(rsession_pid_file)"
}

function terminate_rserver {
    local pid
    pid=$(rserver_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}" && mdebug "rserver (PID ${pid}) terminated"
}

function terminate_rsession {
    local pid
    pid=$(rsession_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}" && mdebug "rsession (PID ${pid}) terminated"
}

function rserver_hostname {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    cat "${workdir}/rserver.hostname"
}

function rserver_port {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    cat "${workdir}/rserver.port"
}

function rserver_url {
    echo "http://$(rserver_hostname):$(rserver_port)"
}

function launch_rserver {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    hostname > "${workdir}/rserver.hostname"
    grep -E "www-port=" ~/.config/rsc/rserver.conf | sed 's/www-port=//' > "${workdir}/rserver.port"

    pid_file=$(rserver_pid_file)
    rserver --config-file="${workdir}/rserver.conf" &
    echo $! > "${pid_file}"
}


# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=
dryrun=false
force=false
verbose=false
args=()
full=false
port=${RSTUDIO_PORT:-8787}
[[ -n ${port} ]] && validate_port "$port"

# Parse command-line options
while [[ $# -gt 0 ]]; do
    mdebug "Next CLI argument: $1"
    ## Commands:
    if [[ "$1" == "start" ]]; then
        action="$1"
    elif [[ "$1" == "status" ]]; then
        action="$1"
    elif [[ "$1" == "stop" ]]; then
        action="$1"
    elif [[ "$1" == "reset" ]]; then
        action="$1"
    elif [[ "$1" == "config" ]]; then
        action="$1"
    elif [[ "$1" == "log" ]]; then
        action="$1"

    ## Options (--flags):
    elif [[ "$1" == "--help" ]]; then
        action=help
    elif [[ "$1" == "--version" ]]; then
        action=version
    elif [[ "$1" == "--debug" ]]; then
        debug=true
    elif [[ "$1" == "--dry-run" ]]; then
        dryrun=true
    elif [[ "$1" == "--verbose" ]]; then
        verbose=true
    elif [[ "$1" == "--force" ]]; then
        force=true
    elif [[ "$1" == "--full" ]]; then
        full=true
        
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            merror "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "port" ]]; then
            port=${value}
            if [[ "${value}" != "random" ]]; then
                validate_port "${port}"
            fi
        else
            merror "Unknown option: $1"
        fi
    ## Additional options to be appended (rarely needed)
    else
        args+=("$1")
    fi
    shift
done


## --help should always be available prior to any validation errors
if [[ -z $action ]]; then
    help
    _exit 0
elif [[ $action == "help" ]]; then
    help full
    _exit 0
elif [[ $action == "version" ]]; then
    version
    $full && catfs_version
    _exit 0
fi


# -------------------------------------------------------------------------
# Validate options
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# Initiate
# -------------------------------------------------------------------------
mdebug "action: ${action}"
mdebug "debug: ${debug}"
mdebug "verbose: ${verbose}"
mdebug "dryrun: ${dryrun}"
mdebug "force: ${force}"
mdebug "port: ${port}"
mdebug "args: [n=${#args[@]}] ${args[*]}"


if [[ "${action}" == "config" ]]; then
    files=()
    workdir=$(config_dir)
    echo "config-dir=${workdir}"

    echo "lockfile=${workdir}/pid.lock"

    file=${workdir}/rserver.conf
    echo "config-file=${file}"
    files+=("${file}")

    file=${workdir}/rsession.conf
    echo "config-file=${file}"
    files+=("${file}")

    file=${workdir}/rsession.sh
    echo "rsession-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.sh
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.hostname
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.port
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    echo "rserver-pid-file=$(rserver_pid_file)"
    echo "rsession-pid-file=$(rsession_pid_file)"
    echo "rsession-log-file=${workdir}/rsession.log"

    if $full; then
        echo
        for file in "${files[@]}"; do
            if [[ -f "${file}" ]]; then
                ruler
                echo "${file}"
                ruler
                cat "${file}"
            fi
        done
    fi
elif [[ "${action}" == "log" ]]; then
    workdir=$(config_dir)
    file=${workdir}/rsession.log
    if [[ -f "${file}" ]]; then
        ruler
        echo "${file}"
        ruler
        cat "${file}"
    else
        echo "No rsession log file: ${file}"
    fi
elif [[ "${action}" == "status" ]]; then
    pid=$(rserver_pid)
    if [[ -n "${pid}" ]]; then
        echo "rserver: running (pid ${pid})"
    else
        echo "rserver: not running"
    fi
    pid=$(rsession_pid)
    if [[ -n "${pid}" ]]; then
        echo "rsession: running (pid ${pid})"
    else
        echo "rsession: not running"
    fi
elif [[ "${action}" == "stop" ]]; then
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock
    ## If running, make sure we're stopping from the correct machine
    if [[ -f "${lockfile}" ]] && [[ "${HOSTNAME}" != "$(rserver_hostname)" ]]; then
        error "Stopping the RStudio Server can only be made from the machine ($(rserver_hostname)) where it was started from"
    fi

    ## Terminate rsession
    pid=$(rsession_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}"

    ## Terminate rserver
    pid=$(rserver_pid)
    [[ -n "${pid}" ]] && kill -TERM "${pid}"

    ## Remove lock file
    remove_lock_file    
elif [[ "${action}" == "reset" ]]; then
    $force || acquired_lock_file
    workdir=$(config_dir)
    [[ -d "${workdir}" ]] && rm -rf "${workdir}"
elif [[ "${action}" == "start" ]]; then
    ## Assert executables are available
    assert_executable R
    assert_executable rserver
    assert_executable rsession
  
    validate_auth
  
    make_config_dir  
    acquired_lock_file
    
    make_database_conf
    make_rserver_conf "${port}"
    make_rsession_sh
    make_rsession_conf

    ## Make sure to stop the RStudio Server and any R sessions on exit
    mdebug "Registering 'trap ... EXIT"
    trap "terminate_rsession; terminate_rserver; remove_lock_file" EXIT
    
    launch_rserver
    mdebug "RStudio Server started (pid $(rserver_pid))" 1>&2
    
    LOCALPORT=${LOCALPORT:-8787}
    LOGIN_HOST=${LOGIN_HOST:-c4-log2.ucsf.edu}
    echo "RStudio Server is available on <$(rserver_url)>. If you are running from a remote machine without direct access to $(rserver_hostname), you can use SSH port forwarding to access the RStudio Server at <http://127.0.0.1:8787> by running 'ssh -J ${USER}@${LOGIN_HOST} -L ${LOCALPORT}:$(rserver_hostname):$(rserver_port) $(rserver_hostname)' in a second terminal. To stop the server, press Ctrl-C here, or run 'rsc stop' on $(rserver_hostname) in another shell."
    mdebug "Waiting for 'rserver' (pid $(rserver_pid)) to finish"
    wait
fi
