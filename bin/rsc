#! /usr/bin/env bash
### rsc: An RStudio Server Controller
### 
### Usage:
###  rsc <command> [options]
### 
### Commands:
###  start               Start the RStudio Server
###  wait                Wait for RStudio Server instance to be available
###  stop                Stop the RStudio Server and any R and SSH sessions
###  status              Check whether the RStudio Server is running or not
###  config              Output configuration details
###  reset               Wipe all configuration
###  log                 Output rsession log
###  
### Options:  
###  --help              Display the full help page with examples
###  --version           Output version of this software
###  --debug             Output detailed debug information
###  --verbose           Output informative message
###  --quiet             Silence all output
###  --auth=<file>:<ext> Path to authentication executable, or name of one of
###                      the built-in ones: 'auto-via-su' authenticates via
###                      'su', 'auth-via-ssh' authenticates via 'ssh' toward
###                      host <ext>, and 'auth-via-env' authenticates toward
###                      password in environment variable 'RSC_PASSWORD'
###                      (Default: auth-via-su)
###  --revtunnel=<spec>  Hostname and port where the RStudio Server instance
###                      should be exposed. (Default: local host and --port)
###  --random-password   Generate a random password assigned to 'RSC_PASSWORD'
###  --force             Force an action
###  --full              Output more information
###  --no-ssh            Skip anything involving SSH
###  
###  --env-pattern=<re>  Regular expression matching environment variables to be
###                      exported. To export all, use "^.+$". To export none,
###                      use "^$". (Default: "^.+$")
###  --port=<int>        A port in [1,65535]. If 'port4me' (default), a free,
###                      user-specific, pseudo-random, but deterministic port
###                      in [1024,65535] is used
###  --localport=<int>   A port in [1,65535]. If 'port', then the same port as
###                      the port given by --port (Default: 'port'). This
###                      argument is only for the instructions on how to set up
###                      SSH port forwarding, in case RStudio Server runs on a
###                      remote machine
### ---
###
### Example:
###  rsc --help
###  rsc --version
###  rsc --version --full
###
###  rsc start
###  rsc start --port=8787
###  rsc start --port=port4me (default)
###
###  rsc status
###  rsc status --full
###
###  rsc stop
###
###  rsc config
###  rsc config --full
###  rsc log
###
### Version: 0.13.9-9000
### Copyright: Henrik Bengtsson (2022-2023) and Harry Putnam (2022)
### License: ISC

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

## Import bash utility functions
incl="$(dirname "${this}")/incl"
utils="$(dirname "${this}")/utils"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/ports.sh
source "${incl}/ports.sh"
# shellcheck source=incl/port4me.bash
source "${incl}/port4me.bash"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"


# =========================================================================
# Utility functions
# =========================================================================
## If the length of the default
## '$server_data_dir/rstudio-rserver/session-server-rpc.socket', where
## server_data_="$HOME/.config/rsc/run/a", is 108 symbols or more, we get
## an 'ERROR Unexpected exception: File name too long [system:36]; LOGGED
## FROM: int main(int, char* const*) src/cpp/server/ServerMain.cpp:941'.
## This errors occurs in
## <https://github.com/rstudio/rstudio/blob/09de542e287bdbfb6e90babf439eb1e2f9658f05/src/cpp/server/session/ServerSessionRpc.cpp#L229>
## when serverRpcSocketPath() returns a FilePath with an absolute path
## longer than 107 characters. Thus, if '$server_data_dir' has more than
## 65 characters, we hit this bug.  Using the default, this means that
## user with a $HOME folder with more than 47 characters will be affected
## by this bug.
## /HB 2023-04-17
post_mortem_too_long_server_data_dir() {
    local path
    path=$(rserver_data_dir)
    if [[ ${#path} -ge 66 ]]; then
        echo "Post-mortem analysis: The RStudio Server 'server-data-dir' folder ($path) has ${#path} characters, which is more than 65 and will therefore not work with RStudio Server version after 2022.02.4-500. Try setting 'export _RSC_RSERVER_DATA_DIR_=\"\$(mktemp -d)\"' before calling 'rsc start' as a workaround."
    fi
}

function rsc_error {
    local msg extra
    msg="$* This happened with rsc $(version), RStudio Server $(rserver_version_string) [$(rserver_path)], and R $(r_version_string) [$(r_path)]."
    extra=$(post_mortem_too_long_server_data_dir)
    if [[ -n ${extra} ]]; then
        msg="${msg} ${extra}"
    fi
    error "$msg"
}

# -------------------------------------------------------------------------
# Authentication utilities
# -------------------------------------------------------------------------
function auth_tool {
    local file

    mdebug "auth_tool() ..."
    mdebug " - auth: ${auth}"
    [[ -z ${auth} ]] && error "[INTERNAL] No authentication tool specified"
    
    mdebug " - PATH: ${utils}:\${PATH}"
    
    ## Look up authentication executable
    file=$(PATH=${utils}:${PATH} command -v "${auth}")
    mdebug " - file: ${file}"
    [[ -z ${file} ]] && error "No such authentication executable: ${auth}"
    
    assert_executable "${file}"
    file=$(realpath "${file}")
    mdebug " - absolute(file): ${file}"

    mdebug "auth_tool() ... done"
    
    echo "${file}"
}

function validate_auth {
    local bin
    local res
    bin=$(auth_tool)
    
    ## Validate correctness of auth-via-su executable (should return false)
    echo "" | RSC_AUTH_LOGFILE="" "${bin}" "${USER}" &> /dev/null
    res=$?
    mdebug "res=${res}"
    
    ## Something missing?
    if [[ "${res}" -eq 2 ]]; then
        error "Authenatication tool '$(basename "${bin}")' could not test credentials: $(echo "" | RSC_AUTH_LOGFILE="" "${bin}" "${USER}")"
    elif [[ "${res}" -eq 0 ]]; then  ## we expect failure
        error "Validation of '$(basename "${bin}")' failed: ${bin}"
    fi         
    [[ -n ${RSC_AUTH_LOGFILE} ]] && warn_auth_logfile
}

function warn_auth_logfile {
  warn "*************************************************************"
  warn "* Environment variable 'RSC_AUTH_LOGFILE' is set:"
  warn "* ${RSC_AUTH_LOGFILE}"
  warn "*************************************************************"
  echo
}

## Parse --auth=<spec> specification
function parse_auth {
    local spec
    local file
    local ext
    spec=${1:?}
    
    if echo "${spec}" | grep -q -E "^([^:]+)$"; then
        file=${spec}
    elif echo "${spec}" | grep -q -E "^([^:]+):([^:]+)$"; then
        file=${spec/:*/}
        ext=${spec/$file:/}
    else
        error "Invalid --auth=<spec> specification: ${spec}"
    fi
    echo "${file}"
    echo "${ext}"
}


# -------------------------------------------------------------------------
# Configuration utilities
# -------------------------------------------------------------------------
## Need a workdir for sqlite database, otherwise we'd have to be root.
## Also for our rsession.sh
function config_dir {
    local path
    path=${XDG_CONFIG_HOME:-$HOME/.config}
    echo "${path}/rsc"
}

## I think, rserver is designed so that any user on the system should be
## able to write to ${config_dir}/rsc/var/run/rstudio-server/ and it's
## subfolder rstudio-rsession/ when they log in and launch a new 'rsession',
## because the file permissions are changed to 777 when 'rserver' starts.
## Because of this, it is important that ${config_dir} is private (700) to
## the user who lanched 'rsc'. However, to be on the safe side, we're
## setting this for everything recursively.
function secure_dir {
    local path
    mdebug "secure_dir() ..."
    path=${1:-$(config_dir)}
    [[ -z "${path}" ]] && error "secure_dir() requires a folder as first argument"
    mdebug " - config_dir='${path}'"
    [[ -d "${path}" ]] && chmod -R 700 "${path}"
    mdebug "secure_dir() ... done"
}

function make_config_dir {
    local path
    local datadir
    
    path=$(config_dir)
    mkdir -p "${path}"/{lib,run,tmp}
    secure_dir "${path}"
    
    datadir=$(rserver_data_dir)
    mkdir -p "${datadir}"
    secure_dir "${datadir}"

    ## Secure parent folder of the rserver data directory, because RStudio
    ## Server will change the permissions on the data directory itself.
    secure_dir "$(dirname "${datadir}")"
}


# -------------------------------------------------------------------------
# RStudio Server configuration file
# -------------------------------------------------------------------------
# Source: https://docs.rstudio.com/ide/server-pro/r_sessions/workspace_management.html#storage-location-customization
function rstudio_config_dir {
    local path
    path=${RSTUDIO_DATA_HOME}
    if [[ -z ${path} ]]; then
        path=${XDG_CONFIG_HOME:-$HOME/.local/share}/rstudio
    fi
    echo "${path}"
}


# -------------------------------------------------------------------------
# Lock-file utilities
# -------------------------------------------------------------------------
## Prevent user from running multiple instances of the RStudio Server
function acquire_lock_file {
    local workdir
    local lockfile
    workdir=$(config_dir)

    lockfile=${workdir}/pid.lock
    if [[ -f "${lockfile}" ]]; then
        error "${USER}, another RStudio Server instance of yours is already running on $(rserver_hostname) on this system. Call '${blue}rsc status --full${undo}' for details on how to reconnect. If you want to start a new instance, please terminate the existing one first by calling '${blue}rsc stop${undo}' from that machine."
    fi
    echo "${PPID}" > "${lockfile}"
}

function remove_lock_file {
    local workdir
    local lockfile
    mdebug "remove_lock_file() ..."
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock
    mdebug " - lock file: ${lockfile}"
    [[ -f "${lockfile}" ]] && rm "${lockfile}" && mdebug "Lock file removed: ${lockfile}"
    mdebug "remove_lock_file() ... done"
}    


function remove_stray_lockfile {
    local workdir
    local lockfile
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock

    mdebug "remove_stray_lockfile() ..."
    
    ## Nothing to do?
    [[ ! -f "${lockfile}" ]] || [[ -n "$(rserver_pid true)" ]] || [[ -n "$(rsession_pid true)" ]] || [[ -n "$(ssh_revtunnel_pid true)" ]] && return 0;
    
    ## Here we know that there's neither a rserver PID nor a rsession PID
    rm "${lockfile}"
    warn "Detected a stray lock file (${lockfile}). This file was removed, because there was no evidence that another instance was running on this system (no PID files for neither 'rserver' nor 'rsession' were found)."

    mdebug "remove_stray_lockfile() ... done"
}


function remove_stray_pid_file {
    local workdir
    local file
    local pid_file
    local -i pid
    local rserver_hostname
    local what

    what=${1:?}

    mdebug "remove_stray_pid_file(what='${what}'):"
    
    workdir=$(config_dir)
    
    if [[ "${what}" == "rserver" ]]; then
        pid_file="$(rserver_pid_file)"
    elif [[ "${what}" == "rserver_monitor" ]]; then
        pid_file="$(rserver_monitor_pid_file)"
    elif [[ "${what}" == "rsession" ]]; then
        pid_file="$(rsession_pid_file)"
    elif [[ "${what}" == "ssh_revtunnel" ]]; then
        pid_file="$(ssh_revtunnel_pid_file)"
    else
        error "Unknown PID file type: ${what}"
    fi
    mdebug " - pid_file=${pid_file}"
    
    ## Nothing to do?
    [[ ! -f "${pid_file}" ]] && return 0;

    ## Get PID
    ## If PID file is empty, 'pid' is assigned 0, because we
    ## declared it as an integer above.
    pid=$(read_pid true "${pid_file}")
    mdebug " - pid=${pid}"
    
    ## If PID file isEmpty PID (shouldn't really happen)
    if [[ ${pid} -eq 0 ]]; then
        rm "${pid_file}"
         warn "Detected a stray PID file (${pid_file}). This file was removed, because it was empty."
        return 0
    fi

    ## Nothing to do?
    file="${workdir}/rserver.hostname"
    mdebug " - rserver hostname file=${file}"
    [[ ! -f "${file}" ]] && return 0;

    ## Get rserver hostname
    rserver_hostname=$(cat "${file}")
    mdebug " - rserver hostname=${rserver_hostname}"
    mdebug " - hostname=$(hostname)"

    ## If this process is not running, remove the PID file
    pid=$(check_pid "${pid}" "${rserver_hostname}")
    relay_condition "${pid}"
    if [[ -z ${pid} ]]; then
        rm "${pid_file}"
        warn "Detected a stray PID file (${pid_file}). This file was removed, because it referred to a ${what} process (PID ${pid} on ${rserver_hostname}) which is no longer running."
        return 0
    fi
}



# -------------------------------------------------------------------------
# Configuration utilities
# -------------------------------------------------------------------------
function make_database_conf {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    {
        echo "provider=sqlite"
        ## Default: /var/lib/rstudio-server
        echo "directory=${workdir}/lib"
    } > "${workdir}/database.conf"
}

function make_rserver_conf {
    local workdir
    local datadir
    local port
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    port=${1:?}

    datadir=$(rserver_data_dir)
    
    if [[ "${port}" == "port4me" ]]; then
        port=$(PORT4ME_TOOL=rsc port4me 2>&1)
        relay_condition "${port}"
    fi
    assert_port_free "${port}"

    {
        ## For legacy accounts with UID in [500,999] on C4
        echo "auth-minimum-user-id=500"

        ## Enable [sic!] multi-user authentication, i.e. don't disable it
        echo "auth-none=0"
        
        echo "auth-pam-helper-path=$(auth_tool)"
        
        ## Require re-sign in if idle for 30 minutes
        ## Specifically, if user makes no input to the RStudio Server, they
        ## will be automatically logged out after this time and be redirected
        ## to the 'Sign in to RStudio' page
        echo "auth-timeout-minutes=30"

        ## Path to RStudio Server configuration file
        echo "database-config-file=${workdir}/database.conf"

        ## Path to the 'rsession' executable
        echo "rsession-path=${workdir}/rsession.sh"
        
        ## Path to 'rsession.conf'
        echo "rsession-config-file=${workdir}/rsession.conf"
        
        echo "secure-cookie-key-file=${workdir}/tmp/my-secure-cookie-key"

        ## Run 'rserver' as a regular non-privileged process
        echo "server-daemonize=0"

        ## Folder where RStudio Server writes run-time state
        echo "server-data-dir=${datadir}"

        ## Run 'rserver' as this user
        echo "server-user=${USER:?}"

        ## Default working directory of the 'rserver' process
        echo "server-working-dir=${workdir}"

        ## The web port for the RStudio Server
        echo "www-port=${port:?}"
    } > "${workdir}/rserver.conf"
}


# -------------------------------------------------------------------------
# Misc. utilities
# -------------------------------------------------------------------------
function ssh_timeout {
    local timeout=${RSC_SSH_TIMEOUT:-15}
    assert_integer "${timeout}"
    echo "${timeout}"
}

function parse_revtunnel {
    local spec
    local hostname
    local port
    spec=${1:?}
    
    if echo "${spec}" | grep -q -E "^([^:]+)$"; then
        hostname=${spec}
    elif echo "${spec}" | grep -q -E "^([^:]+):([[:digit:]]+)$"; then
        hostname=${spec/:*/}
        port=${spec/$hostname:/}
        assert_port "${port}"
    else
        error "Invalid --revtunnel=<spec> specification: ${spec}"
    fi
    echo "${hostname}"
    echo "${port}"
}

function check_pid {
    local -i pid
    local hostname
    local pid_exists
    local asterisk
    local timeout

    ## If 'pid' is assigned an empty value, then it becomes pid=0,
    ## because we declared it as an integer above.
    pid=${1:?}
    hostname=${2:-$(hostname)}
    
    ## Output PID if there is such a process, otherwise output nothing
    mdebug "check_pid(pid=${pid}, hostname=${hostname}) ..."

    pid_exists=false
    asterisk=false
    if [[ ${pid} -ne 0 ]]; then
        ## Check PID on local machine or another machine?
        if [[ "${hostname}" == "$(hostname)" ]]; then
            mdebug "- Checking /proc/${pid} on current machine (${hostname})"
            [[ -d "/proc/${pid}" ]] && pid_exists=true
        elif ${ssh}; then
            mdebug "- Checking /proc/${pid} on ${hostname} over SSH ($(ssh_timeout)-second timeout)"
            #shellcheck disable=SC2029
            res=$(ssh -o ConnectTimeout="$(ssh_timeout)" "${hostname}" "[[ -d '/proc/${pid}' ]] && echo true || echo false" 2>&1) || error "Failed to check process PID ${pid} on ${hostname} over SSH. Reason was: ${res}"
            [[ "${res}" == "true" ]] && pid_exists=true
        else
            mdebug "- Skipping check of /proc/${pid} on ${hostname}, because --no-ssh"
            pid_exists=true
            asterisk=true
        fi
    fi

    if ${pid_exists}; then
        if ${asterisk}; then
            mdebug "- ${hostname}:/proc/${pid} exists (not verified)"
            echo "${pid}"'*'
        else
            mdebug "- ${hostname}:/proc/${pid} exists"
            echo "${pid}"
        fi
    else
        mdebug "- ${hostname}:/proc/${pid} does not exist"
        echo ""
    fi
    mdebug "check_pid(pid=${pid}, hostname=${hostname}) ... done"
}

function read_pid {
    local keep
    local file
    local -i pid
    keep="${1:?}"
    file="${2:?}"
    mdebug "read_pid(keep=${keep}, file='${file}') ..."
    pid=0
    if [[ -f "${file}" ]]; then
        mdebug "- reading ..."
        pid=$(cat "${file}")
    fi
    mdebug "- pid=${pid}"

    ! $keep && [[ ${pid} -ne 0 ]] && pid=$(check_pid "${pid}")
    mdebug "- pid=${pid}"
    
    mdebug "read_pid(keep=${keep}, file='${file}') ... done"
    echo "${pid}"
}    

function on_local_machine {
    ## If who shows a entry with LINE that has :0 or similar, then that
    ## suggests the user is on the current machine, and not logged in
    ## from elsewhere
    who | grep -E "^${USER}" | grep -q -E "[[:space:]]:[[:digit:]]+[[:space:]]"
}

function find_login_host_via_who {
    local bfr
    bfr=$(who | grep -E "^${USER}")
    if [[ -n "${bfr}" ]]; then
        mdebug "1. ${bfr}"
        ## Drop entries with LINE suggesting direct login
        bfr=$(echo "${bfr}" | grep -v -E "[[:space:]]:[[:digit:]]+[[:space:]]")
        mdebug "2. ${bfr}"
        ## Look only at the last entry
        bfr=$(echo "${bfr}" | tail -n -1)
        mdebug "3. ${bfr}"
        ## Extract the hostname
        bfr=$(echo "${bfr}" | sed -E 's/(.*[[:space:]]+[(]|[)][[:space:]]*)//g')
        mdebug "4. ${bfr}"
        ## If hostname is an IP number, try to identify hostname
	if grep -q -E "^[[:digit:]]+[.][[:digit:]]+[.][[:digit:]]+[.][[:digit:]]+$" <<< "${bfr}"; then
	    if [[ -f /etc/hosts ]] && grep -q -E "\b${bfr}\b" /etc/hosts; then
		bfr=$(grep -E "\b${bfr}\b" /etc/hosts | sed -E "s/\b${bfr}\b//g" | sed -E 's/[[:space:]]+/ /g' | sed -E 's/(^ | $)//g' | cut -d ' ' -f 1)
	    fi
            mdebug "5. ${bfr}"
        fi
    fi
    echo "${bfr}"
}

function find_login_host {
    local host
    local full
    host=${LOGIN_HOSTNAME}
    
    if [[ -z "${host}" ]]; then
        host=$(find_login_host_via_who)
    fi
    
    if [[ -z "${host}" ]]; then
        host="<login-machine>"
    fi

    ## Attempt to look up the DNS entry
    if [[ -n "${host}" ]]; then
        if full=$(host "${host}"); then
            host=$(echo "${full}" | cut -d ' ' -f 1)
        fi
    fi
    echo "${host}"
}

# -------------------------------------------------------------------------
# rsession utilities
# -------------------------------------------------------------------------
## Usage: rs_process_status <pid> <hostname>
function rs_process_status {
    local hostname
    local -i pid
    local pid_info
    local pid_stats
    local tmp
    pid=${1}
    hostname=${2}
    
    mdebug "rs_process_status(pid=${pid}, hostname=${hostname}):"
    
    ## Check if PID is still active?
    if [[ ${pid} -ne 0 ]]; then
        pid=$(check_pid "${pid}" "${hostname}")
        relay_condition "${pid}"
    fi

    
    if [[ ${pid} -ne 0 ]]; then
        pid_info="PID ${pid}"
        ## Gather process details?
        if $full && [[ "${hostname}" == "$(hostname)" ]]; then
            read -r -a tmp <<< "$(ps -p "${pid}" -o "%cpu=,%mem=,rss=,vsize=,state=")"
            pid_stats="$(printf "cpu=%s%%, ram=%s%%, rss=%s KiB, vsize=%s KiB, state=%s" "${tmp[0]}" "${tmp[1]}" "${tmp[2]}" "${tmp[3]}" "${tmp[4]}")"
            pid_stats="${pid_stats}, since=$(ps -p "${pid}" -o "lstart=")"
            pid_info="${pid_info}; ${pid_stats}"
        fi

        if [[ -z ${warning} ]]; then
            echo "running (${pid_info}) on machine (${hostname})"
        else
            warn "${warning}"
            echo "running (${pid_info}) on machine (${hostname}) [guess]"
        fi
    else
        echo "not running"
    fi
}

function rsession_timeout {
    local timeout
    local bfr
    timeout=${RSC_RSESSION_TIMEOUT}

    if [[ -z "${timeout}" ]]; then
        ## The default is 120 minutes (2 hours)
        timeout=120
    fi
    
    mdebug "rsession timeout: ${timeout} minutes"
    assert_integer "${timeout}"
    RSC_RSESSION_TIMEOUT="${timeout}"
    export RSC_RSESSION_TIMEOUT
    echo "${timeout}"
}


function make_rsession_envs {
    local workdir
    local pattern
    local outfile

    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    outfile="${workdir}/rsession.env.parent"
    
    ## Nothing to do?
    if [[ -z ${rsession_inherit_env_pattern} ]] || [[ ${rsession_inherit_env_pattern} == "^$" ]]; then
        rm -f "${outfile}"
        mdebug "Removed: ${workdir}/rsession.env.parent"
        return 0
    fi
    
    ## Exclude 'RSC_PASSWORD', to minimize the risk for leaking
    ## the temporary one-time password via file or elsewhere
    declare -x | grep -v -E "\bRSC_PASSWORD=" > "${outfile}.tmp"
    pattern=${rsession_inherit_env_pattern//^/^declare -x }
    pattern=${pattern//$/=.*$}
    grep -E "${pattern}" "${outfile}.tmp" > "${outfile}.tmp.tmp"
    mv "${outfile}.tmp.tmp" "${outfile}"
    rm -f "${outfile}.tmp"
    mdebug "Created: ${outfile} [$(wc -l "${outfile}" | cut -d ' ' -f 1) variables: $(sed -E 's/(^declare -x |=.*$)//g' "${outfile}" | tr $'\n' ' ' | sed -E 's/ $//' | sed 's/ /, /g')]"
}

function make_rsession_conf {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"
    rsession_timeout > /dev/null
    {
        ## Number of minutes before a session times out, at which point
        ## the session will either suspend
        echo "session-timeout-minutes=$(rsession_timeout)"
        
        ## The default R_LIBS_USER folder that the R session will use
        echo "r-libs-user=${R_LIBS_USER:?}"
    } > "${workdir}/rsession.conf"
}


function make_rsession_sh {
    local workdir
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    cat > "${workdir}/rsession.sh" <<END
#!/usr/bin/env bash

# Set OMP_NUM_THREADS to prevent OpenBLAS (and any other OpenMP-enhanced
# libraries used by R) from spawning more threads than the number of processors
# allocated to the job.
OMP_NUM_THREADS=${OMP_NUM_THREADS:-${SLURM_JOB_CPUS_PER_NODE:-$(nproc 2> /dev/null || echo "1")}}
export OMP_NUM_THREADS

## The PPID can be used to identify child process 'rsession', e.g. ps --ppid <pid>
echo "\${PPID}" > "$workdir/rserver.pid"

RSESSION_LOG_FILE="$workdir/rsession.log"
export RSESSION_LOG_FILE

## Import inherited environment variables?
if [[ -f "${workdir}/rsession.env.parent" ]]; then
    ## (a) Record current env vars
    declare -x > "$workdir/rsession.env.rstudio"
    ## (b) Load inherited env vars
    source "$workdir/rsession.env.parent"
    ## (c) Load recorded env vars (in case they where overwritten)
    source "$workdir/rsession.env.rstudio"
    ## (d) Log env vars to be used
    declare -x > "$workdir/rsession.env"
fi

{
    echo "Time: \$(date --rfc-3339=seconds)"
    echo "hostname: \$(hostname)"
    echo "HOSTNAME: \${HOSTNAME}"
    echo "PPID: \${PPID}"
    echo "PWD: \${PWD}"
    echo "PATH: \${PATH}"
    echo

    echo "R details:"
    R --version 2>&1
    echo

    echo "R_*** environment variables:"
    env | grep -E "^R_"
    echo

    echo "Job-scheduler environment variables:"
    env | grep -E "^(SLURM_)"
    env | grep -E "^(NSLOTS|NHOSTS|SGE_|JOB_|PE_)"
    echo

    echo "Command: exec rsession \${@}"
} > "\${RSESSION_LOG_FILE}"

exec &>> "\${RSESSION_LOG_FILE}"
set -x

exec rsession "\${@}"
END
  
  chmod +x "${workdir}/rsession.sh"
}


function rsession_pid_file {
    local datadir
    datadir=$(rserver_data_dir)
    echo "${datadir}/rstudio-rsession/${USER}-d.pid"
}

function rsession_pid {
    read_pid "${1:-false}" "$(rsession_pid_file)"
}

function terminate_pid {
    local -i pid
    local signals
    local signal
    mdebug "terminate_pid($*) ..."
    pid=${1}
    if [[ ${pid} -ne 0 ]]; then
       shift
       signals=("$@")
       if [[ ${#signals[@]} -eq 0 ]]; then
           signals=("SIGTERM" "SIGTERM" "SIGTERM" "SIGTERM" "SIGKILL")
       fi
       mdebug " - pid: ${pid} (before check)"
       mdebug " - signals: [n=${#signals[@]}] ${signals[*]}"
       pid=$(check_pid "${pid}")
       for kk in $(seq ${#signals[@]}); do
           if [[ ${pid} -eq 0 ]]; then
               break
           fi
           signal=${signals[$((kk - 1))]}
           mdebug "Attempt ${kk}: kill -${signal} ${pid}"
           kill "-${signal}" "${pid}" && mdebug "Sending ${signal} to PID ${pid}"
           sleep 1.0
           pid=$(check_pid "${pid}")
           if [[ ${pid} -ne 0 ]]; then
               warn "Failed to terminate process (PID ${pid}). Will try again in three seconds"
               sleep 2.0
           fi
       done

       if [[ ${pid} -ne 0 ]]; then
           warn "Failed to terminate process (PID ${pid}). Attempted ${#signals[@]} times using signals ${signals[*]}."
       fi
    fi
    mdebug "terminate_pid($*) ... done"
}

function terminate_rsession {
    mdebug "terminate_rsession() ..."
    terminate_pid "$(rsession_pid)"
    mdebug "terminate_rsession() ... done"
}

function rsession_status {
    rs_process_status "$(rsession_pid true)" "$(rserver_hostname)"
}    


# -------------------------------------------------------------------------
# rserver utilities
# -------------------------------------------------------------------------
function rserver_version_string {
    rstudio-server version 2> /dev/null || echo "<not found>"
}

function rserver_version {
    rserver_version_string | sed -E 's/ .*//'
}

function rserver_path {
    command -v rstudio-server || echo "<not found>"
}

function wait_for_rserver {
    workdir=$(config_dir)
    [[ ! -d "${workdir}" ]] && error "There appear to be no RStudio Server instance started"

    ## Wait for PID, hostname, and port file to appear (for up to 5 minutes)
    wait_for_file "${workdir}/rserver.pid"
    wait_for_file "${workdir}/rserver.hostname"
    wait_for_file "${workdir}/rserver.port"

    ## Memoize rserver information (needs to be done in parent process)
    _RSC_RSERVER_PID_=$(rserver_pid)
    _RSC_RSERVER_HOSTNAME_=$(rserver_hostname)
    _RSC_RSERVER_PORT_=$(rserver_port)
    export _RSC_RSERVER_PID_
    export _RSC_RSERVER_HOSTNAME_
    export _RSC_RSERVER_PORT_
}    

function assert_rserver_running {
    mdebug "Checking that the 'rserver' process is still running ..."
    if [[ $(rserver_status) == "not running" ]]; then
        rsc_error "It looks like the RStudio Server failed during launch ['rserver' process (PID $(rserver_pid) on $(rserver_hostname)) no longer exists]."
    fi
    mdebug "Checking that the 'rserver' process is still running ... done"
}


function wait_for_rserver_http {
    local -i port
    local -i res
    local launch_timeout
    local url

    port=$1
    launch_timeout=${_RSC_RSERVER_LAUNCH_TIMEOUT_:-10.0}

    mdebug "Waiting for 'rserver' to respond on HTTP ..."
    mdebug "- timeout: ${launch_timeout} seconds"
    url="http://127.0.0.1:${port}"
    timeout "${launch_timeout}" bash -c "while true; do if curl --silent --head '${url}' > /dev/null; then exit 0; fi; sleep 0.2; done"
    res=$?
    mdebug "- result: ${res}"
    mdebug "Waiting for 'rserver' to respond on HTTP ... done"
    return "${res}"
}

function rserver_data_dir {
    local path
    local workdir

    if [[ -z ${_RSC_RSERVER_DATA_DIR_} ]]; then
        workdir=$(config_dir)
        ## Default: /var/run/rstudio-server
        path="${workdir}/run"
    else
        mdebug "_RSC_RSERVER_DATA_DIR_=${_RSC_RSERVER_DATA_DIR_}"
        path=${_RSC_RSERVER_DATA_DIR_:?}
        
        ## WORKAROUND: This is needed to so that
        ## secure_dir "$(dirname "$(rserver_data_dir)")"
        ## is guaranteed to work, i.e. we need to append a sub folder
        path=${path}/a
    fi
    
    mdebug "rserver_data_dir(): ${path}"
           
    echo "${path}"           
}

function rserver_pid_file {
    local workdir
    workdir=$(config_dir)
    ## Note, this file is created by the 'rsession.sh' script, so
    ## it does not exist until user logs in
    echo "${workdir}/rserver.pid"
}

_RSC_RSERVER_PID_=
function rserver_pid {
    ## Already known?
    if [[ -z "${_RSC_RSERVER_PID_}" ]]; then
         _RSC_RSERVER_PID_=$(read_pid "${1:-false}" "$(rserver_pid_file)")
         export _RSC_RSERVER_PID_ ## NOTE: assigned in the current process
    fi
    echo "${_RSC_RSERVER_PID_}"   
}

_RSC_RSERVER_HOSTNAME_=
function rserver_hostname {
    local workdir
    local file
    local res
    
    ## Already known?
    if [[ -z "${_RSC_RSERVER_HOSTNAME_}" ]]; then
        workdir=$(config_dir)
        assert_dir_exists "${workdir}"
        file="${workdir}/rserver.hostname"
        assert_file_exists "${file}"
        res=$(cat "${file}")
        [[ -z "${res}" ]] && error "File is empty: ${file}"
         _RSC_RSERVER_HOSTNAME_=${res}
         export _RSC_RSERVER_HOSTNAME_ ## NOTE: assigned in the current process
    fi
    echo "${_RSC_RSERVER_HOSTNAME_}"
}

_RSC_RSERVER_PORT_=
function rserver_port {
    local workdir
    local file
    local res
    
    ## Already known?
    mdebug "_RSC_RSERVER_PORT_='${_RSC_RSERVER_PORT_}'"
    if [[ -z "${_RSC_RSERVER_PORT_}" ]]; then
        workdir=$(config_dir)
        assert_dir_exists "${workdir}"
        file="${workdir}/rserver.port"
        assert_file_exists "${file}"
        res=$(cat "${file}")
        [[ -z "${res}" ]] && error "File is empty: ${file}"
         _RSC_RSERVER_PORT_=${res}
         export _RSC_RSERVER_PORT_ ## NOTE: assigned in the current process
    fi
    echo "${_RSC_RSERVER_PORT_}"
}

function rserver_url {
    echo "http://$(rserver_hostname):$(rserver_port)"
}

function terminate_rserver {
    mdebug "terminate_rserver() ..."
    terminate_pid "$(rserver_pid)"
    mdebug "terminate_rserver() ... done"
}

function launch_rserver {
    local workdir
    local -i rs_pid
    local port
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    hostname > "${workdir}/rserver.hostname"
    grep -E "www-port=" "$(config_dir)/rserver.conf" | sed 's/www-port=//' > "${workdir}/rserver.port"

    port=$(rserver_port)
    assert_port_free "${port}"
    
    pid_file=$(rserver_pid_file)
    mdebug "rserver --config-file=\"${workdir}/rserver.conf\" &"
    if $dryrun; then
        echo "DRYRUN: rserver --config-file=\"${workdir}/rserver.conf\""
        sleep 60 &
    else
        rserver --config-file="${workdir}/rserver.conf" &
    fi
    rs_pid=$!
    echo "${rs_pid}" > "${pid_file}"
    rs_pid=$(rserver_pid)
    mdebug "RStudio Server started (PID ${rs_pid})"
}

function rserver_status {
    local res
    res=$(rs_process_status "$(rserver_pid true)" "$(rserver_hostname)")
    if [[ "${res}" != "not running" ]]; then
        res="${res} listening on port $(rserver_port)"
    fi
    echo "${res}"
}    


function assert_no_rserver {
    local action
    local -i pid
    local -i pids
    local call
    local msg
    local workdir

    action=${1:-error}
    workdir=$(config_dir)
    
    mdebug "assert_no_rserver(action='$1') ..."

    ## Find all 'rserver' processes owned by user
    mapfile -t pids < <(pgrep -u "${UID}" rserver)
    mdebug "rserver PIDs: [n=${#pids[@]}] ${pids[*]}"
    for pid in "${pids[@]}"; do
        mdebug "Inspecting 'rserver' process with PID ${pid}:"
        call=$(ps -o args -p "${pid}" | tail -n -1)
        mdebug " - call: ${call}"
        if grep -q -E -- "--config-file=${workdir}/rserver.conf" <<< "${call}"; then
            msg="Even if there are no lock and PID files, there is another rserver process (PID ${pid}: '${call}') owned by you (${USER}; UID ${UID}) already running on this machine ($(hostname)). If you think this is a stray process, you can try to terminate it using 'kill -SIGTERM ${pid}'. If that does not help, try with the stronger 'kill -SIGKILL ${pid}' as a last resort."
            case ${action} in
                error)
                    error "${msg}";;
                warn)
                    warn "${msg}";;
                *)
                    error "[INTERNAL] Unknown argument to assert_no_rserver(): $1";;
            esac
        fi
    done

    mdebug "assert_no_rserver(action='$1') ... done"
}    



# -------------------------------------------------------------------------
# rserver monitor
# -------------------------------------------------------------------------
function rserver_timeout {
    local timeout
    local bfr
    timeout=${RSC_RSERVER_TIMEOUT}

    if [[ -z "${timeout}" ]]; then
        ## The default is 10 minutes
        timeout=10
    fi
    
    mdebug "rsession timeout: ${timeout} minutes"
    assert_integer "${timeout}"
    RSC_RSERVER_TIMEOUT="${timeout}"
    export RSC_RSERVER_TIMEOUT
    echo "${timeout}"
}


function rserver_monitor_pid_file {
    local workdir
    workdir=$(config_dir)
    echo "${workdir}/rserver_monitor.pid"
}

function rserver_monitor_pid {
    read_pid "${1:-false}" "$(rserver_monitor_pid_file)"
}

function terminate_rserver_monitor {
    mdebug "terminate_rserver_monitor() ..."
    terminate_pid "$(rserver_monitor_pid)"
    mdebug "terminate_rserver_monitor() ... done"
}

function rserver_monitor_status {
    rs_process_status "$(rserver_monitor_pid true)" "$(rserver_hostname)"
}    

function rserver_monitor {
    local -i endtime
    local state
    state="wait_and_terminate_rserver"
    
    ## Add 60 seconds leeway for the startup delay
    endtime=$((SECONDS + (60 * $(rserver_timeout)) + 60 ))
    
    mdebug "rserver_monitor() ..."
    while true; do
        ## Shutdown itself?
        if [[ $(rserver_status) == "not running" ]]; then
            mdebug "rserver_monitor(): The 'rserver' process (PID $(rserver_pid)) does not exists, so stopping the monitoring"
            break
        fi
        
        mdebug "rserver_monitor(): state_=${state}"
        if [[ "${state}" == "wait_for_rsession_to_end" ]]; then
            if [[ $(rsession_status) == "not running" ]]; then
                state="wait_and_terminate_rserver"
                endtime=$((SECONDS + (60 * $(rserver_timeout)) ))
                mwarn "The RStudio Server (PID $(rserver_pid)) will time out in $(rserver_timeout) minutes on $(date --rfc-3339=seconds --date="+$(rserver_timeout) minutes"), unless a new R session is started"
            fi
        elif [[ "${state}" == "wait_and_terminate_rserver" ]]; then
            ## Reset or check countdown watch?
            if [[ $(rsession_status) != "not running" ]]; then
                state="wait_for_rsession_to_end"
                minfo "The RStudio Server timeout countdown was reset, because a new R session (PID $(rsession_pid)) was started"
            else
                mdebug "rserver_monitor(): countdown clock: $((endtime - SECONDS)) seconds"
                if [[ ${SECONDS} -gt ${endtime} ]]; then
                    mwarn "The RStudio Server (PID $(rserver_pid)) was shut down on $(date --rfc-3339=seconds) after $(rserver_timeout) minutes without an active R session"
                    terminate_rserver
                    terminate_ssh_revtunnel
                fi
            fi
        fi
        mdebug "rserver_monitor(): sleep"
        sleep 15  ## check status every 15 seconds
    done
    mdebug "rserver_monitor() ... done"
}

function launch_rserver_monitor {
    local workdir
    local -i pid
    workdir=$(config_dir)
    assert_dir_exists "${workdir}"

    pid_file=$(rserver_monitor_pid_file)
    if $dryrun; then
        echo "DRYRUN: rserver_monitor launched"
        sleep 60 &
    else
        rserver_monitor &
    fi
    pid=$!
    echo "${pid}" > "${pid_file}"

    pid=$(rserver_pid)
    mdebug "rserver monitor started (PID ${pid})"
}


# -------------------------------------------------------------------------
# R utils
# -------------------------------------------------------------------------
function assert_r {
    assert_executable R

    out=$(R --version) || error "The R installation appears broken. Calling 'R --version' failed [${out}]"
    
    out=$(R --help) || error "The R installation appears broken. Calling 'R --help' failed [${out}]"

    out=$(R --vanilla -e 42) || error "The R installation appears broken. Calling 'R --vanilla -e 42' failed [${out}]"
}


function r_version_string {
    if command -v R > /dev/null; then
        R --version | head -1 | sed 's/R version //'
    else
        echo "<not found>"
    fi
}

function r_version {
    r_version_string | sed 's/ .*//' || echo "<not found>"
}

function r_path {
    command -v R || echo "<not found>"
}


# -------------------------------------------------------------------------
# SSH reverse-tunnel connection
# -------------------------------------------------------------------------
function ssh_revtunnel_pid_file {
    local workdir
    workdir=$(config_dir)
    echo "${workdir}/ssh-revtunnel.pid"
}

function ssh_revtunnel_spec_file {
    local workdir
    workdir=$(config_dir)
    echo "${workdir}/ssh-revtunnel.spec"
}

_RSC_RSERVER_PID_=
function ssh_revtunnel_pid {
    read_pid "${1:-false}" "$(ssh_revtunnel_pid_file)"
}

function ssh_revtunnel_hostname {
    local file
    local tmp
    file=$(ssh_revtunnel_spec_file)
    if [[ -f "${file}" ]]; then
        mapfile -t tmp < "${file}"
        echo "${tmp[0]}"
    fi
}

function ssh_revtunnel_port {
    local file
    local tmp
    file=$(ssh_revtunnel_spec_file)
    if [[ -f "${file}" ]]; then
        mapfile -t tmp < "${file}"
        echo "${tmp[1]}"
    fi
}

function ssh_revtunnel_status {
    rs_process_status "$(ssh_revtunnel_pid true)" "$(rserver_hostname)"
}    

function terminate_ssh_revtunnel {
    mdebug "terminate_ssh_revtunnel() ..."
    terminate_pid "$(ssh_revtunnel_pid)"
    mdebug "terminate_ssh_revtunnel() ... done"
}


# -------------------------------------------------------------------------
# Signal trap functions
# -------------------------------------------------------------------------
function shutdown {
    message "Shutting down RStudio Server ..."
    terminate_rsession
    terminate_rserver
    terminate_rserver_monitor
    terminate_ssh_revtunnel
    remove_lock_file
    {
        remove_stray_lockfile
        remove_stray_pid_file rsession
        remove_stray_pid_file rserver
        remove_stray_pid_file rserver_monitor
        remove_stray_pid_file ssh_revtunnel
        rm -f "$(ssh_revtunnel_spec_file)"
    } > /dev/null
    message "Shutting down RStudio Server ... done"
}
function exit_on_signals {
    local exit_code
    local signal
    local cmd
    exit_code=${1:?}
    assert_integer "${exit_code}"
    shift
    for signal in "$@"; do
        mdebug "Registering trap: ${signal} => exit ${exit_code}"
        cmd="message 'Received a ${signal} signal => exit ${exit_code}'; exit ${exit_code}"
        mdebug "- trap \"${cmd}\" \"${signal}\""
        #shellcheck disable=SC2064
        trap "${cmd}" "${signal}"
    done
}


# -------------------------------------------------------------------------
# Information
# -------------------------------------------------------------------------
function display_access_instructions {
    local msg

    msg="${USER}, your personal RStudio Server $(rserver_version) running R $(r_version) is available on:\n\n"

    if [[ ${#revtunnel[@]} -gt 0 ]]; then
        if [[ "$(ssh_revtunnel_status)" != "not running" ]]; then
            msg="${msg}  <${blue}http://$(ssh_revtunnel_hostname):$(ssh_revtunnel_port)${undo}>\n"
        elif on_local_machine; then
            msg="${msg}  <${blue}http://127.0.0.1:$(rserver_port)${undo}>\n"
	fi
    else
        hostname=$(rserver_hostname)
        port=$(rserver_port)
        if [[ ${localport} == "port" ]]; then
	    localport=$port
	fi
        msg="${msg}  <${blue}http://127.0.0.1:${port}${undo}>\n"

	if [[ -n ${SSH_CLIENT} ]] || [[ -n ${SSH_CONNECTION} ]] || [[ -n ${SSH_TTY} ]]; then
	msg="${msg}\nImportantly, if you are running from a remote machine without direct access to ${hostname}, you need to set up SSH port forwarding first, which you can do by running:\n\\n  ${blue}ssh -L ${localport}:${hostname}:${port} ${USER}@$(find_login_host)${undo}\n\nin a second terminal from your local computer.\n"
        fi
    fi
    
    message "\n${msg}"
}


# =========================================================================
# MAIN
# -------------------------------------------------------------------------
## Actions
action=
dryrun=false
force=false
verbose=false
quiet=false
args=()
full=false
port=${RSC_PORT:-port4me}
localport=${RSC_LOCALPORT:-port}
field=
auth=${RSC_AUTH:-auth-via-su}
revtunnel=()
ssh=${RSC_SSH:-true}

## Should 'rsession' inherit exported environment variables from the
## 'rsc' process?  If 'false', then the default behavior of 'rserver'
## is to use a a clean set of environment variables.  That default
## behavior prevents R from seeing, for instance, environment variables
## set by a job scheduler.
rsession_inherit_env_pattern=${RSC_ENV_PATTERN:-"^.+$"}
    

# Parse command-line options
while [[ $# -gt 0 ]]; do
    mdebug "Next CLI argument: $1"
    ## Commands:
    if [[ "$1" == "start" ]]; then
        action="$1"
    elif [[ "$1" == "wait" ]]; then
        action="$1"
    elif [[ "$1" == "status" ]]; then
        action="$1"
    elif [[ "$1" == "stop" ]]; then
        action="$1"
    elif [[ "$1" == "reset" ]]; then
        action="$1"
    elif [[ "$1" == "config" ]]; then
        action="$1"
    elif [[ "$1" == "log" ]]; then
        action="$1"

    ## Options (--flags):
    elif [[ "$1" == "--help" ]]; then
        action=help
    elif [[ "$1" == "--version" ]]; then
        action=version
    elif [[ "$1" == "--debug" ]]; then
        debug=true
    elif [[ "$1" == "--dryrun" ]]; then
        dryrun=true
    elif [[ "$1" == "--verbose" ]]; then
        verbose=true
    elif [[ "$1" == "--quiet" ]]; then
        quiet=true
    elif [[ "$1" == "--force" ]]; then
        force=true
    elif [[ "$1" == "--full" ]]; then
        full=true
    elif [[ "$1" == "--no-ssh" ]]; then
        ssh=false
    elif [[ "$1" == "--random-password" ]]; then
        RSC_PASSWORD="random"
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            merror "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "port" ]]; then
            port=${value}
        elif [[ "${key}" == "localport" ]]; then
            localport=${value}
        elif [[ "${key}" == "env-pattern" ]]; then
            rsession_inherit_env_pattern=${value}
        elif [[ "${key}" == "field" ]]; then
            field=${value}
        elif [[ "${key}" == "auth" ]]; then
            [[ -z "${auth}" ]] && error "Option '--auth' must not be empty"
            mapfile -t tmp < <(parse_auth "${value}")
            auth=${tmp[0]}
            [[ -z "${auth}" ]] && error "Option '--auth=${value}' mispecified"
            RSC_AUTH_ARG_2=${tmp[1]}
            export RSC_AUTH_ARG_2
        elif [[ "${key}" == "revtunnel" ]]; then
            [[ -z "${value}" ]] && error "Option '--revtunnel' must not be empty"
            mapfile -t revtunnel < <(parse_revtunnel "${value}")
        else
            merror "Unknown option: $1"
        fi
    ## Additional options to be appended (rarely needed)
    else
        args+=("$1")
    fi
    shift
done


## --help should always be available prior to any validation errors
if [[ -z $action ]]; then
    help
    _exit 0
elif [[ $action == "help" ]]; then
    help full
    _exit 0
elif [[ $action == "version" ]]; then
    if $full; then
        echo "rsc: $(version)"
        echo "RStudio Server: $(rserver_version_string) [$(rserver_path)]"
        echo "R: $(r_version_string) [$(r_path)]"
    else
        version
    fi
    _exit 0
fi


# -------------------------------------------------------------------------
# Validate options
# -------------------------------------------------------------------------
## Validate 'port':
if [[ "${port}" == "random" ]]; then
    port="port4me"
    mwarn "--port=random is deprecated in favor of --port=port4me (default)"
elif [[ "${port}" == "uid" ]]; then
    port="port4me"
    mwarn "--port=uid is deprecated in favor of --port=port4me (default)"
elif [[ "${port}" != "port4me" ]]; then
    assert_port "${port}"
fi

## Validate 'localport':
if [[ "${localport}" != "port" ]]; then
    assert_port "${localport}"
fi



# -------------------------------------------------------------------------
# Initiate
# -------------------------------------------------------------------------
mdebug "action: ${action}"
mdebug "debug: ${debug}"
mdebug "verbose: ${verbose}"
mdebug "dryrun: ${dryrun}"
mdebug "force: ${force}"
mdebug "port: ${port}"
mdebug "rsession_inherit_env_pattern: ${rsession_inherit_env_pattern}"
mdebug "field: ${field}"
mdebug "auth: ${auth}"
mdebug "RSC_AUTH_ARG_2: ${RSC_AUTH_ARG_2}"
mdebug "revtunnel: [n=${#revtunnel[@]}] ${revtunnel[*]}"
mdebug "ssh: ${ssh}"
mdebug "args: [n=${#args[@]}] ${args[*]}"

## Enable terminal colors, if supported
term_colors enable

## Remove any stray files
if ! ${force}; then
    remove_stray_pid_file rserver
    remove_stray_pid_file rsession
    remove_stray_pid_file rserver_monitor
    remove_stray_lockfile
fi    

if [[ "${action}" == "config" ]]; then
    files=()

    echo "RStudio Server Controller Storage:"
    echo "XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-<not set>}"
    
    workdir=$(config_dir)
    echo "config-dir=${workdir}"

    echo "lockfile=${workdir}/pid.lock"

    file=${workdir}/rserver.conf
    echo "config-file=${file}"
    files+=("${file}")

    file=${workdir}/rsession.conf
    echo "config-file=${file}"
    files+=("${file}")

    file=${workdir}/rsession.sh
    echo "rsession-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.sh
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.hostname
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    file=${workdir}/rserver.port
    echo "rserver-sh-file=${file}"
    files+=("${file}")

    echo "rserver-pid-file=$(rserver_pid_file)"
    echo "rsession-pid-file=$(rsession_pid_file)"
    echo "rsession-log-file=${workdir}/rsession.log"
    echo "rserver-monitor-pid-file=$(rserver_monitor_pid_file)"

    if $full; then
        echo
        for file in "${files[@]}"; do
            if [[ -f "${file}" ]]; then
                ruler "-"
                echo "${file}"
                ruler "-"
                cat "${file}"
            fi
        done
    fi

    echo 
    echo "RStudio User State Storage:"
    echo "XDG_DATA_HOME=${XDG_DATA_HOME:-<not set>}"
    echo "RSTUDIO_DATA_HOME=${RSTUDIO_DATA_HOME:-<not set>}"
    workdir=$(rstudio_config_dir)
    echo "RStudio config folder=${workdir}"
    if $full && [[ -d "${workdir}" ]]; then
        du --human-readable --si --summarize "${workdir}"/*
        if [[ -d "${workdir}"/sessions/active/ ]]; then
            res=$(du --human-readable --si "${workdir}"/sessions/active/*/suspended-session-data/ 2> /dev/null)
            if [[ -n ${res} ]]; then
                echo "Suspended RStudio Session Data:"
                echo "$res"
            fi
        fi
    fi        
elif [[ "${action}" == "log" ]]; then
    workdir=$(config_dir)
    file=${workdir}/rsession.log
    if [[ -f "${file}" ]]; then
        ruler "-"
        echo "${file}"
        ruler "-"
        cat "${file}"
    else
        echo "No rsession log file: ${file}"
    fi
elif [[ "${action}" == "status" ]]; then
    mdebug "rsc status ..."
    if [[ -z ${field} ]]; then
        status="rserver: $(rserver_status)\n"
        status="${status}rsession: $(rsession_status)\n"
        status="${status}rserver monitor: $(rserver_monitor_status)\n"
        status="${status}SSH reverse tunnel (optional): $(ssh_revtunnel_status)"
        
        ## AD HOC: Is there an asterisk on the pid?
        if grep -q -E 'pid [[:digit:]]+[*]' <<< "${status}"; then
            status="${status}\n* This is only assumed, because without SSH (--no-ssh) we couldn't confirm the process is still running"
        fi
        
        echo -e "${status}"
        workdir=$(config_dir)
        lockfile=${workdir}/pid.lock
        if [[ -f "${lockfile}" ]]; then
            echo "lock file: exists (${lockfile})"
        else
            echo "lock file: does not exist"
        fi

        ## Display info on how to reconnect?
        if $full; then
            res=$(rs_process_status "$(rserver_pid true)" "$(rserver_hostname)")
            if [[ "${res}" != "not running" ]]; then
                message "\nInformation on how to reconnect:"
                display_access_instructions
            fi
        fi
    else
        ! ${force} && [[ "$(rserver_status)" == "not running" ]] && error "Not running"
        if [[ "${field}" == "port" ]]; then
            rserver_port
        elif [[ "${field}" == "hostname" ]]; then
            rserver_hostname
        fi
    fi
    ## Warn about stray 'rserver' processes on the current machine
    ! ${force} && [[ "$(rserver_status)" == "not running" ]] && assert_no_rserver warn
    mdebug "rsc status ... done"
elif [[ "${action}" == "stop" ]]; then
    workdir=$(config_dir)
    lockfile=${workdir}/pid.lock
    ## If running, make sure we're stopping from the correct machine
    if [[ -f "${lockfile}" ]] && [[ "$(hostname)" != "$(rserver_hostname)" ]]; then
        error "Stopping the RStudio Server can only be made from the machine ($(rserver_hostname)) where it was started from"
    fi

    ## Terminate rsession
    terminate_rsession

    ## Terminate rserver
    terminate_rserver

    ## Terminate rserver monitor
    terminate_rserver_monitor

    ## Terminate SSH reverse-tunnel connection
    terminate_ssh_revtunnel

    ## Remove lock file
    remove_lock_file
    
    message "RStudio Server stopped"
elif [[ "${action}" == "reset" ]]; then
    workdir=$(config_dir)
    if [[ -d "${workdir}" ]]; then
        files=("$(rsession_pid_file)" "${workdir}/rserver.pid""${workdir}/rserver_monitor.pid" "${workdir}/rserver.hostname" "${workdir}/rserver.port" "${workdir}/pid.lock")
        if $force; then
            existing=()
            for file in "${files[@]}"; do
                [[ -f "${file}" ]] && existing+=("${file}")
            done
            mdebug "Files that will be deleted: ${existing[*]}"
            if [[ ${#existing[@]} -gt 0 ]]; then
                warn "Deleting rsc folder and files (${existing[*]}) without checking if there is an active RStudio Server instance: ${workdir}"
            fi
        else
            acquire_lock_file
        fi
        rm -rf "${workdir}"
    fi
elif [[ "${action}" == "wait" ]]; then
    wait_for_rserver    
    rserver_hostname
    rserver_port
elif [[ "${action}" == "start" ]]; then    
    ## Assert executables are available
    assert_executable R
    assert_r
    assert_executable rserver
    assert_executable rsession
    if [[ "${port}" != "port4me" ]]; then
        assert_port_free "${port}"
    fi
    
    if [[ "${RSC_PASSWORD}" == "random" ]]; then
        RSC_PASSWORD=$(openssl rand -base64 15)
        export RSC_PASSWORD
        RSC_PASSWORD_ECHO=${RSC_PASSWORD_ECHO:-true}
    fi
    
    validate_auth

    make_config_dir
    acquire_lock_file
    
    make_database_conf
    make_rserver_conf "${port}"
    make_rsession_envs
    make_rsession_sh
    make_rsession_conf

    mdebug "PID for rsc (this process): $$"

    ## Assert that there is no rserver process created by rsc running
    assert_no_rserver
    
    ## Shutdown nicely
    mdebug "Registering 'trap shutdown EXIT', which perform cleanups"
    trap shutdown EXIT
    exit_on_signals 0 SIGCONT SIGINT SIGTERM SIGUSR2
    
    launch_rserver
    wait_for_rserver
    secure_dir
    
    rs_pid="$(rserver_pid)"
    [[ -z "${rs_pid}" ]] && error "RStudio Server failed to start for unknown reasons. One reason for this might be that the port (${port}) is already occupied"
    pids=("${rs_pid}")
    
    ## Update 'port', in case it 'port4me' was used
    port=$(rserver_port)

    ## Launch rserver monitor
    launch_rserver_monitor
    pid="$(rserver_monitor_pid)"
    [[ -z "${pid}" ]] && error "rserver monitor failed to start for unknown reasons"
    pids=("${pid}")

    ## Launch reverse SSH tunnel?
    if [[ ${#revtunnel[@]} -gt 0 ]]; then
        if ! ${ssh}; then
            error "Cannot setup reverse SSH tunnel, because --no-ssh was used"
        fi
        mdebug "Setting up reverse SSH tunnel ..."
        rev_hostname=${revtunnel[0]}
        rev_port=${revtunnel[1]}
        mdebug " - hostname: ${rev_hostname}"
        mdebug " - rev port: ${rev_port}"
        [[ -z ${rev_port} ]] && rev_port=${port}
        rev_spec=${rev_port}:localhost:${port}
        mdebug " - rev spec: ${rev_spec}"

        pid_file=$(ssh_revtunnel_pid_file)
        if $dryrun; then
            echo "DRYRUN: ssh -o ConnectTimeout=\"$(ssh_timeout)\" -N -R \"${rev_spec}\" \"${rev_hostname}\""
            sleep 60 &
        else
            mdebug "ssh -o ConnectTimeout=\"$(ssh_timeout)\" -N -R \"${rev_spec}\" \"${rev_hostname}\""
            printf "%s\n%s\n" "${rev_hostname}" "${rev_port}" > "$(ssh_revtunnel_spec_file)"
            ssh -o ConnectTimeout="$(ssh_timeout)" -N -R "${rev_spec}" "${rev_hostname}" &
        fi
        ssh_pid=$!
        echo "${ssh_pid}" > "${pid_file}"
        ssh_pid=$(ssh_revtunnel_pid false)
        mdebug "Reverse SSH tunnel started (PID ${ssh_pid})"
        pids+=("${ssh_pid}")
        
        mdebug "Setting up reverse SSH tunnel ... done"
    fi

    ## Check if RStudio Server failed during launch
    assert_rserver_running

    ## Wait for RServer Studio HTTP interface to come up
    wait_for_rserver_http "${port}" || warn "RStudio Server is not responding on <http://127.0.0.1:${port}>, but let's try anyway"

    ## Check if RStudio Server failed during launch
    assert_rserver_running

    ## Give instructions
    display_access_instructions

    message "Any R session started times out after being idle for $(rsession_timeout) minutes."
 
    mwarn "You now have $(rserver_timeout) minutes, until $(date --rfc-3339=seconds --date="+$(rserver_timeout) minutes"), to connect and log in to the RStudio Server before everything times out."

    if ${RSC_PASSWORD_ECHO:-false}; then
        message "Your password for this RStudio Server instance is: ${blue}${RSC_PASSWORD}${undo}"
    fi

    ## Check if RStudio Server failed during launch (on last time)
    assert_rserver_running
    
    mdebug "Waiting for background process (PIDs ${pids[*]}) to finish ..."
    wait "${pids[@]}"
    res=$?
    mdebug "'rserver' exit code: ${res}"
    mdebug "Waiting for 'rserver' (PID ${rs_pid}) to finish ... done"
    mdebug "$0 is exiting..."
fi
